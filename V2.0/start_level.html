<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Academy</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Press+Start+2P&display=swap"
        rel="stylesheet">
    <script type="module">
        // This script is intentionally left blank.
        // The API key has been moved to a secure serverless function.
    </script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }

        .game-container {
            position: relative;
        }

        .game-console-body {
            background: linear-gradient(145deg, #3c3c3c, #1e1e1e);
            border-radius: 30px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            border: 2px solid #111;
            width: auto;
            max-width: 100%;
            max-height: 90vh;
            aspect-ratio: 1534 / 1024;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.7), 0 10px 30px rgba(0, 10px, 30px, 0.5);
        }

        #canvas-header {
            color: #aaa;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .control-button {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 8px 16px;
            border-radius: 5px;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-button:hover {
            background-color: #444;
            border-color: #777;
        }

        #start-button {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 40px;
            font-size: 28px;
            font-family: 'Roboto Mono', monospace;
            background-color: rgba(10, 25, 40, 0.7);
            color: #a0e9ff;
            border: 2px solid #50c8e8;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #start-button:hover {
            background-color: rgba(15, 35, 55, 0.9);
            border-color: #70d8ff;
            box-shadow: 0 0 20px rgba(80, 200, 232, 0.5);
        }

        #intro-popup {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            padding: 40px;
            background-color: rgba(20, 30, 50, 0.95);
            border: 3px solid #00ffff;
            border-radius: 15px;
            z-index: 3000;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        #intro-popup h2 {
            color: #00ffff;
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            margin-bottom: 25px;
            text-shadow: 0 0 10px #00ffff;
        }

        #intro-popup p {
            color: #ffffff;
            font-size: 20px;
            line-height: 1.6;
            margin-bottom: 30px;
        }

        #intro-popup .instruction {
            color: #ffff00;
            font-size: 22px;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <div class="game-console-body">
            <div id="canvas-header">PROMPT ACADEMY</div>
            <canvas id="game-canvas" width="1534" height="1024"></canvas>
            <button id="start-button">Start</button>
            <div id="game-controls" style="display: none;">
                <button id="save-button" class="control-button">Save Game</button>
                <button id="load-button" class="control-button">Load Last Save</button>
                <button id="new-game-button" class="control-button">New Game</button>
            </div>
        </div>
    </div>

    <!-- Introduction Popup -->
    <div id="intro-popup">
        <h2>Welcome to Prompt Academy</h2>
        <p>You're about to enter a world where AI assistants and language models shape reality.
        Your mission: Learn the art of prompting and unlock the potential of these powerful tools.</p>
        <p class="instruction">Press [E] to begin your journey</p>
    </div>

    <script type="module">
        // Import game utilities
        import { analytics, navigateToLevel } from './game_utils.js';
        // Save/Load functionality
        function saveGame() {
            try {
                if (typeof gameState !== 'undefined') {
                    localStorage.setItem('startLevelSave_v1', JSON.stringify(gameState));
                }
            } catch (error) {
                console.error("Could not save game:", error);
            }
        }

        function loadGame() {
            try {
                const savedData = localStorage.getItem('startLevelSave_v1');
                if (savedData && typeof gameState !== 'undefined') {
                    const loadedState = JSON.parse(savedData);
                    Object.assign(gameState, loadedState);
                    
                    // Fix: Clear any active dialogues since action functions can't be serialized
                    gameState.activeDialogue = {
                        isActive: false,
                        speaker: null,
                        text: '',
                        displayText: '',
                        charIndex: 0,
                        options: [],
                        selectedOption: 0
                    };
                }
            } catch (error) {
                console.error("Could not load game:", error);
                localStorage.removeItem('startLevelSave_v1');
            }
        }

        function handleInteraction() {
            const { nearbyObject, activeDialogue, tutorialState } = gameState;
            if (!nearbyObject || activeDialogue.isActive) return;

            const { id } = nearbyObject;

        if (gameState.gameMode==='tutorial') {
            if (id==='ratio_start' && !gameState.ratio.synced) {
                handleRatioSyncInteraction();
            }

            else if (id==='door' && gameState.ratio.synced && !tutorialState.doorOpen) {

                // Function to show door command options
                const showDoorOptions=() => {
                    startDialogue("Door", "Pick a command:", [ {
                            text: "'I order you to open!'", action: () => {
                                startDialogue("Door", "*The door remains silent and unmoving.*", [ {
                                        text: "Continue", action: () => {
                                            getRatioDialogue("The command failed. The door doesn't know what it is. Hint that it needs to be told what it is. Example: 'It doesn't know what it is - try telling it directly.' OR SOMETHING VERY VERY SIMILAR. Keep it super short, one sentence max. DO NOT mention anything else unrelated to this.");

                                            }
                                        }

                                        ]);
                                }
                            }

                            ,
                            {
                            text: "'Open the door please'", action: () => {
                                startDialogue("Door", "*A silent hum.... no response.*", [ {
                                        text: "Continue", action: () => {
                                            getRatioDialogue("The user tried being polite but the door still didn't respond. The door doesn't know it's a door. Hint that it needs to be told what it is and what to do. Example: 'Being nice won't help if it doesn't know it's a door - tell it what it is.' OR SOMETHING VERY VERY SIMILAR. Keep it super short, one sentence max. DO NOT mention anything else unrelated to this.");

                                            }
                                        }

                                        ]);
                                }
                            }

                            ,
                            {
                            text: "'Act like a door, you are unlocked, now open!'", action: () => {
                                tutorialState.doorOpen=true;

                                // Analytics: Track door opened
                                analytics.log('door_opened', {
                                    timeElapsed: Date.now() - analytics.sessionStart,
                                    hintShown: tutorialState.doorHintShown
                                });

                            startDialogue("Door", "*With a deep groan, the door swings open.*", [ {
                                    text: "Enter", action: closeDialogue
                                }

                                ]);
                            tutorialState.step=4;
                            saveGame();
                        }
                    }

                    ,
                    ]);
            }

            ;

            // First time: Show error and RATIO's hint
            if ( !tutorialState.doorHintShown) {
                startDialogue("Door", "Error, command not understood.", [ {
                        text: "Continue", action: () => {
                            // RATIO immediately steps in with helpful hint
                            getRatioDialogue("The door just gave an error. Explain that this door forgets what it is sometimes and doesn't know what to do. Tell the user to try telling the door what it's supposed to be and what it should do. Be clear and helpful. Example: 'This door forgets what it is sometimes - try telling it what it's supposed to be.' OR SOMETHING VERY VERY SIMILAR. Keep it super short, one sentence max. DO NOT mention anything else unrelated to this.", () => {
                                // Mark hint as shown and show options
                                tutorialState.doorHintShown=true;

                                gameState.activeDialogue.options=[ {
                                    text: "Continue", action: showDoorOptions
                                }

                                ];
                            });
                    }
                }

                ]);
        }

        else {
            // Subsequent times: Go directly to options
            showDoorOptions();
        }
        }

        else if (id==='door' && tutorialState.doorOpen) {
            gameState.gameMode='transitionToLevel1';
            gameState.transitionAlpha=0;
        }

        }

        else if (gameState.gameMode==='level1') {
            if (id==='cog' || id==='loom' || id==='chip') {
                if ( !gameState.level1State.inventory[id]) {
                    // Start resonance tuning mini-game
                    startResonanceTuning(id);
                }
            }

            else if (id==='broken_gary') {
                if (gameState.level1State.garyFixed) {
                    getGaryDialogue("The user is talking to you after you have been fixed. Thank them again and offer to help.");
                    }

                    else {
                        handleGaryInteraction();
                    }
                }

                else if (id==='biodome_door') {
                    if ( !gameState.level1State.garyFixed) {
                        // Don't show any dialogue if Gary isn't fixed yet - door is hidden
                        return;
                    }

                    else if (gameState.level1State.levelComplete) {
                        // Navigate to ecology level (works with both local and Netlify)
                        window.location.href=window.location.hostname==='localhost' || window.location.hostname==='127.0.0.1'
                        ? 'ecology_level.html'
                        : '/ecology_level';
                    }

                    else {

                        startDialogue("Ratio", "The Bio-Dome is locked. You'll need to complete Level 1 first by helping GARY.",
                            [ {
                                text: "Understood", action: closeDialogue
                            }

                            ]);
                    }
                }
            }
        }

        function handleRatioSyncInteraction() {
            const {
                tutorialState
            }

            =gameState;

            switch (tutorialState.ratioSyncStep) {
                case 0: startDialogue("Ratio", "Wait…. Who the hell are you? What are you doing here?", [ {
                        text: "I am just a human…", action: () => {
                            tutorialState.ratioSyncStep=1;
                            handleRatioSyncInteraction();
                        }
                    }

                    ,
                    {
                    text: "I'm… not really sure.", action: () => {
                        getRatioDialogue("The user says they are not sure why they are here. Respond with a light, playful comment that's a bit grumpy but not mean. Keep it super short, one sentence max.", () => {
                            tutorialState.ratioSyncStep=1;
                            handleRatioSyncInteraction();
                        });
                }
            }

            ]);
        break;

        case 1: startDialogue("Ratio", "Nevermind... I was about to head inside. Sync with me if you want to come.", [ {
                text: "Okay, let's sync.", action: () => {
                    gameState.ratio.synced=true;
                    tutorialState.step=3;
                    gameState.ratio.x=gameState.player.x - 50;
                    gameState.ratio.y=gameState.player.y;

                    // Analytics: Track Ratio sync
                    analytics.log('ratio_synced', {
                        timeElapsed: Date.now() - analytics.sessionStart
                    });

                getRatioDialogue("The user agreed to sync. Welcome them and point them toward the door. Hint that you cannot open it yourself. Example sentences you could use: 'Welcome to the mess. Let's go, door's that way.' or 'All right then, here's the door. Give me a hand, will you? Obviously I don't have one.' Keep it super short, one sentence max.");

                }
            }

            ,
            {
            text: "Emmmm, no that sounds weird.", action: () => {
                getRatioDialogue("The user is refusing to sync. Tell them there's nowhere else to go and nothing else to do - they need to sync. Use one of these examples or something VERY similar (don't change much): 'Well, there's nowhere else to go anyway.' or 'Suit yourself, but there's nothing else to do here.' or 'Your call, friend, but you're kind of stuck otherwise.' Keep it super short, one sentence max. Stick close to the examples.");
                    }
                }

                ]);
            break;
        }
        }

        function handleGaryInteraction() {
            const {
                level1State
            }

            =gameState;

            if ( !level1State.inventory.cog || !level1State.inventory.loom || !level1State.inventory.chip) {
                getRatioDialogue("The player is trying to fix GARY but doesn't have all the parts yet. Tell them to find the parts first by looking around. Example: 'We need to find the parts first - look around the yard.' OR SOMETHING VERY VERY SIMILAR. Keep it super short, one sentence max. DO NOT mention specific locations like garages, bins, or toolboxes. Just say 'around here' or 'the yard' or 'the place'.");
                return;
                }

                switch (level1State.garyDialogueStep) {
                    case 0: startDialogue("GARY", "*whirr...* Identity not found... State purpose...", [ {
                            text: "I want to help you come back to life.", action: () => {
                                level1State.garyDialogueStep=1;
                                handleGaryInteraction();
                            }
                        }

                        ,
                        {
                        text: "I want to pass to the next level.", action: () => {
                            startDialogue("GARY", "Threat detected. Defensive protocols active. *BZZT*");
                        }
                    }
                    ,
]);
                            break;

                            case 1: startDialogue("RATIO", "To build GARY into life, what is most needed? Put in the first component.", [ {
                                    text: "Install Brain Chip (To think)", action: () => {
                                        level1State.garyDialogueStep=2;
                                        handleGaryInteraction();
                                    }
                                }

                                ,
                                {
                                text: "Install Language Chip (To speak)", action: () => {
                                    startDialogue("GARY", "SEQUENCE ERROR.", [ {
                                            text: "Continue", action: () => {
                                                startDialogue("RATIO", "Language without a mind??? GARY must first exist before it can talk.");
                                                level1State.garyDialogueStep=0;
                                            }
                                        }

                                        ]);
                                }
                            }

                            ,
                            {
                            text: "Install Personality Chip (To feel)", action: () => {
                                startDialogue("GARY", "SEQUENCE ERROR.", [ {
                                        text: "Continue", action: () => {
                                            startDialogue("RATIO", "Feeling without thinking is chaos! GARY must first exist before it can feel.");
                                            level1State.garyDialogueStep=0;
                                        }
                                    }

                                    ]);
                            }
                        }

                        ]);
                    break;

                    case 2: startDialogue("GARY", "I compute, therefore I am... Acknowledged.", [ {
                            text: "Continue", action: () => {
                                startDialogue("RATIO", "A mind is formed. Now make him talk? Present the second module.", [ {
                                        text: "Install Language Chip (To speak)", action: () => {
                                            level1State.garyDialogueStep=3;
                                            handleGaryInteraction();
                                        }
                                    }

                                    ,
                                    {
                                    text: "Install Personality Chip (To feel)", action: () => {
                                        startDialogue("GARY", "SEQUENCE ERROR. Emotion before logic invites overload. A thinking mind needs the structure of reason before it can process emotion.");
                                        level1State.garyDialogueStep=0;
                                        }
                                    }

                                    ]);
                            }
                        }

                        ]);
                    break;

                    case 3: startDialogue("GARY", "Language online. My thoughts have structure.", [ {
                            text: "Continue", action: () => {
                                startDialogue("RATIO", "Present the final module.", [ {
                                        text: "Install Personality Chip (To feel)", action: () => {
                                            level1State.garyFixed=true;
                                            level1State.arrowActive=true;
                                            level1State.arrowVisible=true;
                                            level1State.garyAnimationState='wakingUp';

                                            startDialogue("GARY", "I... understand. Thank you, friend. The Academy grounds are yours to explore. I shall be here if you need assistance.", [{
                                                text: "Continue", action: () => {
                                                    level1State.levelComplete=true;
                                                    level1State.completeMessageTimer=5;

                                                    // Analytics: Track Level 1 completion
                                                    analytics.log('level_complete', {
                                                        level: 1,
                                                        totalTime: Date.now() - analytics.sessionStart
                                                    });

                                                saveGame();
                                                closeDialogue();
                                            }
                                        }

                                        ]);
                                }
                            }

                            ]);
                    }
                }

                ]);
            break;
        }
        }

        function handleKeyDown(e) {
            const {
                gameMode, activeDialogue, resonanceState
            }

            =gameState;
            const key=e.key.toLowerCase();

            if (gameMode==='startScreen' || gameMode.startsWith ('transition')) return;

            // Handle resonance tuning input
            if (resonanceState.isActive) {
                if (key==='escape') {
                    endResonanceTuning(false);
                    return;
                }

                // Check if key matches current pattern position
                const expectedKey=resonanceState.pattern[resonanceState.currentIndex];

                if (key===expectedKey) {
                    // Correct key!
                    resonanceState.lastCorrect=true;
                    resonanceState.feedbackTimer=0.3;
                    resonanceState.currentIndex++;
                    resonanceState.successCount++;
                    resonanceState.syncProgress=resonanceState.successCount / resonanceState.requiredSuccess;

                    // Create success particle
                    createResonanceParticle(true);

                    // Check if pattern is complete
                    if (resonanceState.successCount >=resonanceState.requiredSuccess) {
                        setTimeout(() => endResonanceTuning(true), 500);
                    }
                }

                else if (key==='w' || key==='a' || key==='s' || key==='d') {
                    // Wrong key!
                    resonanceState.lastCorrect=false;
                    resonanceState.feedbackTimer=0.3;
                    resonanceState.currentIndex=0; // Reset pattern on mistake
                    resonanceState.successCount=0;
                    resonanceState.syncProgress=0;

                    // Create fail particle
                    createResonanceParticle(false);
                }

                return;
            }

            if (activeDialogue.isActive) {
                if (key==='w' || key==='arrowup') {
                    activeDialogue.selectedOption=(activeDialogue.selectedOption - 1 + activeDialogue.options.length) % activeDialogue.options.length;
                }

                else if (key==='s' || key==='arrowdown') {
                    activeDialogue.selectedOption=(activeDialogue.selectedOption + 1) % activeDialogue.options.length;
                }

                else if (key==='e') {
                    if (activeDialogue.charIndex < activeDialogue.text.length) {
                        activeDialogue.charIndex=activeDialogue.text.length;
                    }

                    else if (activeDialogue.options.length> 0) {
                        activeDialogue.options[activeDialogue.selectedOption].action();
                    }

                    else {
                        closeDialogue();
                    }
                }

                return;
            }

            if (gameState.keys.hasOwnProperty(key)) {
                gameState.keys[key]=true;
                gameState.player.moving=true;
            }

            if (key==='e') handleInteraction();
        }

        function createResonanceParticle(success) {
            const {
                resonanceState
            }

            =gameState;
            const centerX=canvas.width / 2;
            const centerY=canvas.height / 2;

            for (let i=0; i < 5; i++) {
                const angle=Math.random() * Math.PI * 2; const speed=50 + Math.random() * 50;

                resonanceState.particles.push({
                    x: centerX, y: centerY, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 1.0, color: success ? resonancePatterns[resonanceState.currentPiece].color : '#FF0000'
                });
        }
        }

        window.addEventListener('keydown', handleKeyDown); window.addEventListener('keyup', (e) => {
                const key=e.key.toLowerCase();
                if (gameState.keys.hasOwnProperty(key)) gameState.keys[key]=false;

                if ( !gameState.keys.w && !gameState.keys.a && !gameState.keys.s && !gameState.keys.d) {
                    gameState.player.moving=false;
                }
            });

        function startGame() {
            if (gameState.gameMode !=='startScreen') return;

            // Show Intro Popup
            startButton.style.display='none';
            const introPopup=document.getElementById('intro-popup');
            introPopup.style.display='block';

            // Add one-time listener for E key to close popup and start
            const startHandler=(e) => {
                if (e.key.toLowerCase()==='e') {
                    introPopup.style.display='none';
                    window.removeEventListener('keydown', startHandler);

                    gameState.gameMode='transitionToTutorial';
                    startBackgroundMusic(); // Start music when game starts

                    // Analytics: Track tutorial start
                    analytics.log('tutorial_start', {
                        playerPos: {
                            x: gameState.player.x, y: gameState.player.y
                        }
                    });
            }
        }

        ;
        window.addEventListener('keydown', startHandler);
        }

        function checkCollision(rectA, rectB) {
            const buffer=5;
            return rectA.x < rectB.x + rectB.width + buffer && rectA.x + rectA.width + buffer> rectB.x && rectA.y < rectB.y + rectB.height + buffer && rectA.y + rectA.height + buffer> rectB.y;
        }

        function update(deltaTime) {
            const {
                gameMode
            }

            =gameState;

            handlePlayerAnimation(deltaTime);

            if (gameMode==='startScreen') {
                updateStartScreenWander(gameState.startScreenState.finn, gameState.player);
                updateStartScreenWander(gameState.startScreenState.ratio);
                updateLeaves(deltaTime);
                updateGaryStartScreenAnimation(deltaTime);

            }

            else if (gameMode==='transitionToTutorial' || gameMode==='transitionToLevel1') {
                gameState.transitionAlpha +=2.0 * deltaTime;

                if (gameState.transitionAlpha >=1) {
                    if (gameMode==='transitionToLevel1') {
                        gameState.gameMode='level1';
                        gameState.player.x=canvas.width / 2;
                        gameState.player.y=canvas.height - 150;
                        gameState.ratio.x=gameState.player.x - 50;
                        gameState.ratio.y=gameState.player.y;
                    }

                    else {
                        gameState.gameMode='tutorial';
                        gameState.player.x=canvas.width / 2;
                        gameState.player.y=canvas.height - 150;
                        gameState.ratio.x=tutorialInteractables.find(i => i.id==='ratio_start').x;
                        gameState.ratio.y=tutorialInteractables.find(i => i.id==='ratio_start').y;

                    }

                    gameState.transitionAlpha=0;
                }

            }

            else if (gameMode==='tutorial' || gameMode==='level1') {
                if ( !gameState.tutorialState.controlsExplained && gameMode==='tutorial') {
                    startDialogue("Tutorial", "Use W/A/S/D keys to move your character. Press E to interact with objects and characters.", [
                        {
                            text: "Got it!", action: () => {
                                gameState.tutorialState.controlsExplained=true;
                                closeDialogue();
                            }
                        }

                        ]);
                    return; // Pause game update until dialogue is closed
                }

                // Update resonance tuning
                if (gameState.resonanceState.isActive) {
                    const {
                        resonanceState
                    }

                    =gameState;

                    // Update pulse timer
                    resonanceState.pulseTimer +=deltaTime;

                    if (resonanceState.pulseTimer >=resonanceState.pulseDuration) {
                        resonanceState.pulseTimer=0;
                    }

                    // Update feedback timer
                    if (resonanceState.feedbackTimer > 0) {
                        resonanceState.feedbackTimer -=deltaTime;
                    }

                    // Update particles
                    resonanceState.particles=resonanceState.particles.filter(p => {
                            p.x +=p.vx * deltaTime;
                            p.y +=p.vy * deltaTime;
                            p.life -=deltaTime * 2;
                            return p.life > 0;
                        });

                    gameState.player.moving=false;
                    return; // Don't process movement during resonance tuning
                }

                if (gameState.activeDialogue.isActive) {
                    const {
                        activeDialogue
                    }

                    =gameState;

                    if (activeDialogue.charIndex < activeDialogue.text.length) {
                        activeDialogue.charIndex +=30 * deltaTime;
                    }

                    gameState.player.moving=false; return;
                }

                const {
                    player, ratio, keys,
                    tutorialState, level1State
                }

                =gameState; let moved=false; let newPlayerX=player.x; let newPlayerY=player.y; if (keys.w) {
                    newPlayerY -=player.speed * deltaTime; player.frameY=3;
                    moved=true;
                }

                if (keys.s) {
                    newPlayerY +=player.speed * deltaTime; player.frameY=0; moved=true;
                }

                if (keys.a) {
                    newPlayerX -=player.speed * deltaTime; player.frameY=2; ratio.direction='left';
                    moved=true;
                }

                if (keys.d) {
                    newPlayerX +=player.speed * deltaTime; player.frameY=1;
                    ratio.direction='right'; moved=true;
                }

                // Apply boundary collision detection const
                currentBoundaries=gameMode==='tutorial' ? gameState.tutorialBoundaries : gameState.level1Boundaries; const currentAdjustments=gameMode==='tutorial' ? gameState.tutorialBoundaryAdjustments : gameState.level1BoundaryAdjustments; let collisionDetected=false; for (const boundary of currentBoundaries) {
                    let {
                        x, y, width, height
                    }

                    =boundary; const adjustment=currentAdjustments[boundary.id]; if (adjustment) {
                        x +=adjustment.adjustX; y +=adjustment.adjustY; width +=adjustment.adjustWidth; height +=adjustment.adjustHeight;
                    }

                    if (checkCollision({
                            x: newPlayerX, y: newPlayerY, width: player.width, height: player.height
                        }

                        , {
                        x, y, width, height

                    })) {
                collisionDetected=true;
                break;
            }
        }

        if ( !collisionDetected) {
            player.x=newPlayerX; player.y=newPlayerY;
        }

        if (moved) {
            // tutorialState.controlsHintTimer=0; // This was removed previously
        }

        player.x=Math.max(0, Math.min(canvas.width - player.width, player.x));
        player.y=Math.max(0, Math.min(canvas.height - player.height, player.y));

        if (ratio.synced) {
            const dx=player.x - ratio.x; const dy=player.y - ratio.y; const distance=Math.sqrt(dx * dx + dy * dy); if (distance> ratio.followDistance) {
                ratio.x +=(dx / distance) * ratio.speed * deltaTime; ratio.y +=(dy / distance) * ratio.speed * deltaTime;
            }
        }

        gameState.nearbyObject=null;
        const currentInteractables=gameMode==='tutorial' ? tutorialInteractables : level1Interactables;

        for (const obj of currentInteractables) {
            if (gameMode==='level1' && obj.id.match(/cog|loom|chip/) && level1State.inventory[obj.id]) continue;
            if (gameMode==='level1' && obj.id==='biodome_door' && !level1State.garyFixed) continue;

            if (checkCollision(player, obj)) {
                gameState.nearbyObject=obj;
                break;
            }
        }

        if (tutorialState.controlsHintTimer > 0) tutorialState.controlsHintTimer -=deltaTime;

        if ( !ratio.synced && !gameState.activeDialogue.isActive && tutorialState.ratioSyncStep===1) {
            handleRatioSyncInteraction();
        }

        if (gameMode==='level1') {
            updateGaryAnimation(deltaTime);

            if (level1State.completeMessageTimer > 0) {
                level1State.completeMessageTimer -=deltaTime;
            }
        }
        }
        }

        function updateStartScreenWander(character, deltaTime, playerChar=null) {
            if (character.pauseTimer > 0) {
                character.pauseTimer -=deltaTime;
                character.moving=false;
                if (playerChar) playerChar.moving=false;
                return;
            }

            character.moving=true;
            if (playerChar) playerChar.moving=true;

            const dx=character.targetX - character.x;
            const dy=character.targetY - character.y;
            const dist=Math.sqrt(dx * dx + dy * dy);

            if (dist < 5) {
                character.pauseTimer=Math.random() * 3 + 2; character.targetX=Math.random() * (canvas.width - 100); character.targetY=Math.random() * (canvas.height - 150) + 50; return;
            }

            character.x +=(dx / dist) * character.speed * deltaTime; character.y +=(dy / dist) * character.speed * deltaTime; if (playerChar) {
                if (dx> 0) playerChar.frameY=1;
                else if (dx < 0) playerChar.frameY=2;
            }
        }

        function updateLeaves(deltaTime) {
            if (gameState.leaves.length < 150) {
                // Ensure there are enough leaves
                createLeaves(150 - gameState.leaves.length);
            }

        for (const leaf of gameState.leaves) {
            leaf.y +=leaf.speedY * 60 * deltaTime; leaf.x +=leaf.speedX * 60 * deltaTime; leaf.rotation +=leaf.rotationSpeed * 60 * deltaTime; if (leaf.y> canvas.height) {
                leaf.y=-20;
                leaf.x=Math.random() * canvas.width;
                leaf.speedX=Math.sin(Math.random() * Math.PI * 2) * 0.2;
                leaf.opacity=Math.random() * 0.5 + 0.3; // Reset opacity
                leaf.size=Math.random() * 10 + 5; // Reset size
                leaf.speedY=Math.random() * 0.5 + 0.2; // Reset speed
            }
        }
        }

        function updateGaryStartScreenAnimation(deltaTime) {
            const {
                gary
            }

            =gameState.startScreenState;
            gary.timer +=deltaTime;

            if (gary.timer >=1 / GARY_IDLE_FPS) {
                gary.timer=0;
                gary.frame=(gary.frame + 1) % 3;
            }
        }

        function updateGaryAnimation(deltaTime) {
            const {
                level1State
            }

            =gameState;
            if (level1State.garyAnimationState==='off') return;

            const WAKE_UP_FRAMES=4;
            const STAND_UP_FRAMES=5;
            const IDLE_FRAMES=3;
            const WAKE_STAND_FPS=5;

            level1State.garyAnimationTimer +=deltaTime;

            switch (level1State.garyAnimationState) {
                case 'wakingUp': if (level1State.garyAnimationTimer >=1 / WAKE_STAND_FPS) {
                    level1State.garyAnimationTimer=0;
                    level1State.garyAnimationFrame++;

                    if (level1State.garyAnimationFrame >=WAKE_UP_FRAMES) {
                        level1State.garyAnimationState='idle'; // Transition directly to idle
                        level1State.garyAnimationFrame=0;
                    }
                }

                break;

                case 'idle': if (level1State.garyAnimationTimer >=1 / GARY_IDLE_FPS) {
                    level1State.garyAnimationTimer=0;
                    level1State.garyAnimationFrame=(level1State.garyAnimationFrame + 1) % IDLE_FRAMES;
                }

                break;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const {
                gameMode
            }

            =gameState;

            if (gameMode==='startScreen') {
                drawStartScreen();
            }

            else if (gameMode.startsWith ('transition')) {
                const bgImage=gameMode==='transitionToLevel1' ? level1MapImage : doorClosedImage;
                if (bgImage.complete) ctx.drawImage(bgImage, 0, 0, canvas.width,
                    canvas.height);

                ctx.fillStyle=`rgba(0, 0, 0, ${gameState.transitionAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

            }

            else if (gameMode==='tutorial') {
                drawTutorial();
            }

            else if (gameMode==='level1') {
                drawLevel1();
            }
        }

        function drawStartScreen() {
            if (startScreenImage.complete) ctx.drawImage(startScreenImage, 0, 0,
                canvas.width,
                canvas.height);

            drawLeaves();

            ctx.textAlign='center';
            ctx.font='70px "Press Start 2P"';
            ctx.fillStyle='rgba(255, 255, 255, 0.9)';
            ctx.shadowColor="#00ffff";
            ctx.shadowBlur=20;
            ctx.fillText("Prompt Academy", canvas.width / 2, 200);
            ctx.shadowBlur=0;

            const {
                finn: startFinn, ratio: startRatio, gary: startGary
            }

            =gameState.startScreenState;
            const player=gameState.player;

            if (playerImage.complete) {
                const frameX=player.moving ? player.frameX : 0;
                ctx.drawImage(playerImage, frameX * player.spriteWidth, player.frameY * player.spriteHeight,
                    player.spriteWidth, player.spriteHeight, startFinn.x, startFinn.y,
                    PLAYER_DISPLAY_WIDTH,
                    PLAYER_DISPLAY_HEIGHT);
            }

            if (ratioImageR.complete) ctx.drawImage(ratioImageR, startRatio.x,
                startRatio.y,
                RATIO_DISPLAY_WIDTH, RATIO_DISPLAY_HEIGHT);

            // GARY removed from start screen
            // if (fixedGaryIdleImage.complete) {
            // const frameHeight = fixedGaryIdleImage.height / 3;
            // ctx.drawImage(fixedGaryIdleImage, 0, startGary.frame * frameHeight,
            // fixedGaryIdleImage.width, frameHeight,
            // startGary.x, startGary.y,
            // GROUNDSKEEPER_DISPLAY_WIDTH * 1.8, GROUNDSKEEPER_DISPLAY_HEIGHT * 1.8);
            // }
        }

        function drawLeaves() {

            // ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Changed to white for snow
            for (const leaf of gameState.leaves) {
                // Calculate the new size, 50% bigger
                const drawSize=leaf.size * 2.5;

                ctx.save();
                ctx.translate(leaf.x, leaf.y);
                ctx.rotate(leaf.rotation * Math.PI / 180);

                if (snowflakeImage.complete && snowflakeImage.naturalWidth > 0) {
                    ctx.globalAlpha=leaf.opacity;

                    // Use drawSize and ensure it's centered
                    ctx.drawImage(snowflakeImage, -drawSize / 2, -drawSize / 2, drawSize,
                        drawSize);

                    ctx.globalAlpha=1.0; // Reset global alpha
                }

                else {
                    ctx.fillStyle='rgba(255, 255, 255, 0.7)'; // Fallback

                    // Use drawSize and fix centering.
                    // (-drawSize / 2) makes the square's center align with the rotation point.
                    ctx.fillRect(-drawSize / 2, -drawSize / 2, drawSize, drawSize); // centered square for snow
                }

                ctx.restore();
            }
        }


        function drawTutorial() {
            const backgroundImage=gameState.tutorialState.doorOpen ? doorOpenImage : doorClosedImage;

            if (backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }

            const {
                tutorialState, ratio, player
            }

            =gameState;

            let ratioDrawX=ratio.synced ? ratio.x : tutorialInteractables.find(i => i.id==='ratio_start').x;
            let ratioDrawY=ratio.synced ? ratio.y : tutorialInteractables.find(i => i.id==='ratio_start').y;
            const ratioImg=ratio.direction==='left' ? ratioImageL : ratioImageR;
            if (ratioImg.complete) ctx.drawImage(ratioImg, ratioDrawX, ratioDrawY,
                ratio.width,
                ratio.height);

            if (playerImage.complete) ctx.drawImage(playerImage, player.frameX * player.spriteWidth,
                player.frameY * player.spriteHeight,
                player.spriteWidth, player.spriteHeight, player.x, player.y, player.width,
                player.height);

            drawProgressionBar();
            drawHud();
            drawBoundaries(); // Draw boundaries after other elements
            if (gameState.activeDialogue.isActive) drawDialogueBox();
        }

        function drawLevel1() {
            if (level1MapImage.complete) ctx.drawImage(level1MapImage, 0, 0,
                canvas.width,
                canvas.height);

            const {
                level1State, player, ratio
            }

            =gameState;

            level1Interactables.forEach(obj => {
                    if (obj.id.match(/cog|loom|chip/) && !level1State.inventory[obj.id]) {
                        let itemImage;
                        if (obj.id==='cog') itemImage=cogImage;
                        else if (obj.id==='loom') itemImage=loomImage;
                        else if (obj.id==='chip') itemImage=chipImage;

                        if (itemImage && itemImage.complete) {
                            const pulse=Math.abs(Math.sin(Date.now() * 0.005));
                            ctx.globalAlpha=0.8 + pulse * 0.2;
                            ctx.drawImage(itemImage, obj.x, obj.y, obj.width * 2.5, obj.height * 2.5);
                            ctx.globalAlpha=1;
                        }
                    }

                    else if (obj.id==='biodome_door' && level1State.garyFixed && level1State.arrowActive) {
                        // Update blinking logic (simple update in draw for simplicity)
                        level1State.arrowTimer +=0.016; // Approx 60fps

                        if (level1State.arrowTimer > 0.5) {
                            // Blink every 0.5s
                            level1State.arrowVisible= !level1State.arrowVisible;
                            level1State.arrowTimer=0;

                            if ( !level1State.arrowVisible) {
                                level1State.arrowBlinkCount++;

                                if (level1State.arrowBlinkCount >=5) {
                                    level1State.arrowActive=false;
                                }
                            }
                        }

                        if (level1State.arrowVisible) {
                            // Draw mysterious arrow pointing to the door
                            const bounce=Math.sin(Date.now() * 0.005) * 10;

                            // Arrow positioned further left (closer to player/center) and bigger
                            const arrowX=obj.x - 100; // Moved left of the door
                            const arrowY=obj.y + obj.height / 2 + bounce;

                            ctx.save();
                            ctx.fillStyle='rgba(100, 220, 255, 1.0)';
                            ctx.shadowColor='rgba(100, 220, 255, 1.0)';
                            ctx.shadowBlur=20;

                            ctx.translate(arrowX, arrowY);
                            ctx.scale(3, 3); // Significantly bigger (3x)
                            ctx.rotate(-0.5); // Point up-right towards door

                            // Draw arrow shape
                            ctx.beginPath();
                            ctx.moveTo(-25, 0);
                            ctx.lineTo(-18, -9);
                            ctx.lineTo(-18, -4);
                            ctx.lineTo(0, -4);
                            ctx.lineTo(0, 4);
                            ctx.lineTo(-18, 4);
                            ctx.lineTo(-18, 9);
                            ctx.closePath();
                            ctx.fill();

                            ctx.restore();
                        }
                    }
                });

            drawGary();

            const ratioImg=ratio.direction==='left' ? ratioImageL : ratioImageR;
            if (ratioImg.complete) ctx.drawImage(ratioImg, ratio.x, ratio.y,
                ratio.width,
                ratio.height);

            if (playerImage.complete) ctx.drawImage(playerImage, player.frameX * player.spriteWidth,
                player.frameY * player.spriteHeight,
                player.spriteWidth, player.spriteHeight, player.x, player.y, player.width,
                player.height);

            drawProgressionBar();
            drawHud();
            drawBoundaries(); // Draw boundaries after other elements

            if (level1State.completeMessageTimer > 0) {
                ctx.fillStyle='rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 80, canvas.width, 60);
                ctx.font='40px "Press Start 2P"';
                ctx.fillStyle='#00FFFF';
                ctx.textAlign='center';
                ctx.fillText("Level 1 Completed!", canvas.width / 2, 125);
            }

            if (gameState.resonanceState.isActive) drawResonanceTuning();
            if (gameState.activeDialogue.isActive) drawDialogueBox();
        }

        function drawGary() {
            const {
                level1State
            }

            =gameState;
            const garyInteractable=level1Interactables.find(i => i.id==='broken_gary');
            const garyX=garyInteractable.x;
            const garyY=garyInteractable.y;
            const garyWidth=garyInteractable.width * 1.35;
            const garyHeight=garyInteractable.height * 1.35;
            ctx.globalAlpha=1;

            switch (level1State.garyAnimationState) {
                case 'off': if (brokenGaryImage.complete) {
                    ctx.drawImage(brokenGaryImage, garyX, garyY, garyInteractable.width * 1.5,
                        garyInteractable.height * 1.5);
                }

                break;

                case 'wakingUp': if (garyWakeUpImage.complete) {
                    const frameHeight=garyWakeUpImage.height / 4;
                    ctx.drawImage(garyWakeUpImage, 0, level1State.garyAnimationFrame * frameHeight,
                        garyWakeUpImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
                }

                break;

                case 'standingUp': if (garyStandUpImage.complete) {
                    const frameHeight=garyStandUpImage.height / 5;
                    ctx.drawImage(garyStandUpImage, 0, level1State.garyAnimationFrame * frameHeight,
                        garyStandUpImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
                }

                break;

                case 'idle': if (fixedGaryIdleImage.complete) {
                    const frameHeight=fixedGaryIdleImage.height / 3;
                    ctx.drawImage(fixedGaryIdleImage, 0, level1State.garyAnimationFrame * frameHeight,
                        fixedGaryIdleImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
                }

                break;
            }
        }

        function drawResonanceTuning() {
            const {
                resonanceState
            }

            =gameState;
            if ( !resonanceState.currentPiece) return;

            const pattern=resonancePatterns[resonanceState.currentPiece];
            const centerX=canvas.width / 2;
            const centerY=canvas.height / 2;

            // Draw dark overlay
            ctx.fillStyle='rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw component image in center with glow
            const componentImages= {
                cog: cogImage, loom: loomImage, chip: chipImage
            }

            ;
            const componentImg=componentImages[resonanceState.currentPiece];

            if (componentImg && componentImg.complete) {
                const imgSize=120;
                const pulse=Math.sin(resonanceState.pulseTimer / resonanceState.pulseDuration * Math.PI * 2) * 0.5 + 0.5;

                // Glow effect
                ctx.shadowColor=pattern.color;
                ctx.shadowBlur=30 + pulse * 20;
                ctx.globalAlpha=0.8 + pulse * 0.2;
                ctx.drawImage(componentImg, centerX - imgSize / 2, centerY - imgSize / 2,
                    imgSize,
                    imgSize);
                ctx.shadowBlur=0;
                ctx.globalAlpha=1;
            }

            // Draw title
            ctx.font='bold 36px "Roboto Mono"';
            ctx.fillStyle=pattern.color;
            ctx.textAlign='center';
            ctx.fillText(pattern.name, centerX, 100);

            // Draw description
            ctx.font='20px "Roboto Mono"';
            ctx.fillStyle='#AAAAAA';
            ctx.fillText(pattern.description, centerX, 140);

            // Draw pattern sequence
            const patternY=centerY + 150;
            const spacing=70;
            const startX=centerX - (pattern.display.length * spacing) / 2 + spacing / 2;

            pattern.display.forEach((arrow, index) => {
                const x = startX + index * spacing;
                const isCurrentStep = index === resonanceState.currentIndex;
                const isPastStep = index < resonanceState.currentIndex;

                // Pulse effect for current step
                const pulseScale = isCurrentStep ? (Math.sin(resonanceState.pulseTimer / resonanceState.pulseDuration * Math.PI * 2) * 0.2 + 1) : 1;

                // Circle background
                ctx.beginPath();
                ctx.arc(x, patternY, 25 * pulseScale, 0, Math.PI * 2);
                ctx.fillStyle = isPastStep ? pattern.color : (isCurrentStep ? 'rgba(255, 255, 255, 0.2)' : 'rgba(100, 100, 100, 0.3)');
                ctx.fill();

                if (isCurrentStep) {
                    ctx.strokeStyle = pattern.color;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // Arrow
                ctx.font = `${isCurrentStep ? '32' : '28'}px "Roboto Mono"`;
                ctx.fillStyle = isPastStep ? '#000' : (isCurrentStep ? pattern.color : '#666');
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(arrow, x, patternY);
            });

            // Draw progress bar
            const barWidth = 400;
            const barHeight = 30;
            const barX = centerX - barWidth / 2;
            const barY = centerY + 220;

            // Background
            ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Progress fill
            ctx.fillStyle = pattern.color;
            ctx.fillRect(barX, barY, barWidth * resonanceState.syncProgress, barHeight);

            // Border
            ctx.strokeStyle = pattern.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Progress text
            ctx.font = '18px "Roboto Mono"';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText(`${resonanceState.successCount} / ${resonanceState.requiredSuccess}`, centerX, barY + barHeight + 25);

            // Draw feedback
            if (resonanceState.feedbackTimer > 0) {
            const alpha=resonanceState.feedbackTimer / 0.3;
            ctx.globalAlpha=alpha;
            ctx.font='bold 40px "Roboto Mono"';
            ctx.fillStyle=resonanceState.lastCorrect ? pattern.color : '#FF0000';
            ctx.textAlign='center';
            ctx.fillText(resonanceState.lastCorrect ? '✓ SYNC!' : '✗ DESYNC!',
                centerX, centerY - 100);
            ctx.globalAlpha=1;
        }

        // Draw particles
        resonanceState.particles.forEach(p => {
                ctx.globalAlpha=p.life;
                ctx.fillStyle=p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
        ctx.globalAlpha=1;

        // Instructions
        ctx.font='18px "Roboto Mono"';
        ctx.fillStyle='#AAAAAA';
        ctx.textAlign='center';
        ctx.fillText('Press WASD keys to match the rhythm', centerX,
            canvas.height - 80);
        ctx.fillText('ESC to cancel', centerX, canvas.height - 50);
        }

        let frameCounter=0;
        const playerAnimationFPS=10; // Animate at 10 frames per second

        function handlePlayerAnimation(deltaTime) {
            if (gameState.player.moving || (gameState.gameMode==='startScreen' && gameState.startScreenState.finn.moving)) {
                frameCounter +=deltaTime;

                if (frameCounter >=1 / playerAnimationFPS) {
                    frameCounter=0;
                    gameState.player.frameX=(gameState.player.frameX + 1) % 4;
                }
            }

            else {
                gameState.player.frameX=0;
            }
        }

        function drawProgressionBar() {
            const barWidth=600;
            const barHeight=40;
            const barX=(canvas.width / 2) - (barWidth / 2);
            const barY=20;

            ctx.fillStyle='rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.strokeStyle='#888';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.font='18px "Roboto Mono"';
            ctx.textAlign='center';
            ctx.textBaseline='middle';

            const inTutorial=gameState.gameMode==='tutorial';
            const inLevel1=gameState.gameMode==='level1';

            ctx.fillStyle=inTutorial || inLevel1 ? '#00FFFF' : '#555';
            ctx.fillText("Tutorial", barX + (barWidth / 6), barY + barHeight / 2);

            ctx.fillStyle='#888';
            ctx.fillText("-->", barX + (barWidth / 3), barY + barHeight / 2);

            ctx.fillStyle=inLevel1 ? '#00FFFF' : '#555';
            ctx.fillText("Level 1", barX + (barWidth / 2), barY + barHeight / 2);

            ctx.fillStyle='#888';
            ctx.fillText("-->", barX + (barWidth * 2 / 3), barY + barHeight / 2);

            ctx.fillStyle='#555';
            ctx.fillText("Level 2", barX + (barWidth * 5 / 6), barY + barHeight / 2);
        }

        function drawHud() {
            if (gameState.gameMode==='level1') {
                const currentInventory=gameState.level1State.inventory;
                const invWidth=350;
                const invHeight=180;
                ctx.fillStyle='rgba(0, 0, 0, 0.7)';
                ctx.fillRect(canvas.width - invWidth - 20, 20, invWidth, invHeight);
                ctx.strokeStyle='#999';
                ctx.strokeRect(canvas.width - invWidth - 20, 20, invWidth, invHeight);

                ctx.fillStyle='#FFF';
                ctx.font='28px "Roboto Mono"';
                ctx.textAlign='left';
                ctx.fillText("INVENTORY", canvas.width - invWidth + 20, 65);

                ctx.font='22px "Roboto Mono"';
                ctx.fillStyle=currentInventory.cog ? '#FFD700' : '#555';
                ctx.fillText("- Brain Chip", canvas.width - invWidth + 20, 105);
                ctx.fillStyle=currentInventory.loom ? '#00BFFF' : '#555';
                ctx.fillText("- Language Chip", canvas.width - invWidth + 20, 135);
                ctx.fillStyle=currentInventory.chip ? '#FF69B4' : '#555';
                ctx.fillText("- Personality Chip", canvas.width - invWidth + 20, 165);
            }

            if ( !gameState.activeDialogue.isActive) {
                ctx.fillStyle='rgba(0, 0, 0, 0.6)'; ctx.fillRect(0, canvas.height - 60,
                    canvas.width, 60);
                ctx.textAlign='center'; ctx.font='22px "Roboto Mono"'; ctx.fillStyle='#FFFFFF';

                if (gameState.nearbyObject) {
                    const textPart1="Press ";
                    const textPart2="[E]";
                    const textPart3=gameState.nearbyObject.id==='door' ? ` to open the door` : ` to interact with ${gameState.nearbyObject.name}`;

                    // Save current textAlign
                    const originalTextAlign=ctx.textAlign;
                    ctx.textAlign='left';

                    // Measure individual parts
                    const text1Width=ctx.measureText(textPart1).width;
                    const text2Width=ctx.measureText(textPart2).width;
                    const text3Width=ctx.measureText(textPart3).width;

                    // Calculate total width for centering the entire message
                    const totalWidth=text1Width + text2Width + text3Width;

                    // Calculate the starting X for the first part so the whole message is centered
                    let currentX=(canvas.width / 2) - (totalWidth / 2);

                    // Draw each part with its specific color
                    ctx.fillStyle='#FFFFFF';
                    ctx.fillText(textPart1, currentX, canvas.height - 30);
                    currentX +=text1Width;

                    ctx.fillStyle='#FFFF00'; // Yellow for [E]
                    ctx.fillText(textPart2, currentX, canvas.height - 30);
                    currentX +=text2Width;

                    ctx.fillStyle='#FFFFFF';
                    ctx.fillText(textPart3, currentX, canvas.height - 30);

                    // Restore original textAlign
                    ctx.textAlign=originalTextAlign;
                }
            }
        }

        function drawBoundaries() {
            if ( !gameState.showBoundaries) return;

            const {
                gameMode, boundaryThickness, tutorialBoundaryAdjustments,
                level1BoundaryAdjustments
            }

            =gameState;
            let currentBoundaries=[];

            let currentAdjustments= {}

            ;

            if (gameMode==='tutorial') {
                currentBoundaries=gameState.tutorialBoundaries;
                currentAdjustments=tutorialBoundaryAdjustments;
            }

            else if (gameMode==='level1') {
                currentBoundaries=gameState.level1Boundaries;
                currentAdjustments=level1BoundaryAdjustments;
            }

            // Red, semi-transparent for visibility
            ctx.fillStyle='rgba(255, 0, 0, 0.5)';
            currentBoundaries.forEach(boundary => {
                    let {
                        x, y, width, height
                    }

                    =boundary;

                    // Apply adjustments based on boundary ID
                    const adjustment=currentAdjustments[boundary.id];

                    if (adjustment) {
                        x +=adjustment.adjustX;
                        y +=adjustment.adjustY;
                        width +=adjustment.adjustWidth;
                        height +=adjustment.adjustHeight;
                    }

                    ctx.fillRect(x, y, width, height);
                });
        }

        function drawDialogueBox() {
            const {
                activeDialogue
            }

            =gameState;
            activeDialogue.displayText=activeDialogue.text.substring(0,
                activeDialogue.charIndex);

            const boxHeight=200;
            ctx.fillStyle='rgba(0, 0, 0, 0.9)'; ctx.strokeStyle='#FFF';
            ctx.lineWidth=2;
            ctx.fillRect(20, canvas.height - boxHeight - 20, canvas.width - 40,
                boxHeight);
            ctx.strokeRect(20, canvas.height - boxHeight - 20, canvas.width - 40,
                boxHeight);

            ctx.fillStyle='#FFF'; ctx.font='bold 20px "Roboto Mono"';
            ctx.textAlign='left';
            ctx.fillText(activeDialogue.speaker, 140, canvas.height - boxHeight);

            if (activeDialogue.speaker==="Ratio" && ratioImageR.complete) {
                ctx.fillStyle='#111';
                ctx.fillRect(35, canvas.height - boxHeight - 5, 80, 80);
                ctx.drawImage(ratioImageR, 40, canvas.height - boxHeight, 70, 70);
            }

            ctx.font='bold 22px "Roboto Mono"';
            ctx.fillStyle='#99FF99';
            ctx.shadowColor="black";
            ctx.shadowBlur=4;

            const lines=wrapText(activeDialogue.displayText, 90);

            lines.forEach((line, index) => {
                    ctx.fillText(line, 145, canvas.height - boxHeight + 45 + (index * 30));
                });

            if (activeDialogue.charIndex >=activeDialogue.text.length) {
                if (activeDialogue.options.length > 0) {
                    activeDialogue.options.forEach((option, index) => {
                            ctx.fillStyle=index===activeDialogue.selectedOption ? '#FFFF00' : '#99FF99';

                            ctx.fillText(`${index===activeDialogue.selectedOption ? '> ' : ''}${option.text}`,
                                50, canvas.height - boxHeight + 110 + (index * 30));
                        });
                }

                else {
                    ctx.fillStyle='#FFFF00'; // Changed to yellow
                    ctx.fillText("Press [E] to continue...", canvas.width - 450,
                        canvas.height - 40);
                }
            }

            ctx.shadowBlur=0;
        }

        function wrapText(text, maxWidthChars) {
            const words=text.split(' ');
            let lines=[];
            let currentLine=words[0] || '';

            for (let i=1; i < words.length; i++) {
                if ((currentLine + ' ' + words[i]).length> maxWidthChars) {
                    lines.push(currentLine);
                    currentLine=words[i];
                }
                else {
                    currentLine +=' ' + words[i];
                }
            }

            lines.push(currentLine);
            return lines;
        }

        function createLeaves(count=150) {
            for (let i=0; i < count; i++) {
                gameState.leaves.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 10 + 5, speedY: Math.random() * 0.5 + 0.2, speedX: Math.sin(Math.random() * Math.PI * 2) * 0.2, rotation: Math.random() * 360, rotationSpeed: (Math.random() - 0.5) * 2, opacity: Math.random() * 0.5 + 0.3
                });
        }
        }

        let lastTime=0; function gameLoop(time) {
            if (lastTime> 0) {
                const deltaTime=(time - lastTime) / 1000;
                update(deltaTime);
            }

            lastTime=time;
            draw();
            requestAnimationFrame(gameLoop);
        }

        function init() {
            loadGame();

            // Start music immediately if game is already loaded (not on start screen)
            if (gameState.gameMode !=='startScreen') {
                startBackgroundMusic();
            }

        createLeaves();

        // Level Boundaries
        const tutorialBoundaries=[ {
            id: 'tutorial_wall_left', x: 0, y: 0, width: 600, height: canvas.height
        }

        ,
        {
        id: 'tutorial_wall_right', x: 950, y: 0, width: 600,
        height: canvas.height
        }

        ,
        {
        id: 'tutorial_wall_top', x: 0, y: 0, width: canvas.width,
        height: 200
        }

        ,
        {
        id: 'tutorial_wall_bottom', x: 0, y: canvas.height - 100,
        width: canvas.width, height: 100
        }

        ];

        const level1Boundaries=[ // --- Outer Walls ---

            {
            id: 'wall_top', x: 0, y: 0, width: 1534, height: 57
        }

        ,
        {
        id: 'wall_left_top', x: 0, y: 114, width: 205, height: 284
        }

        ,
        {
        id: 'wall_left_main', x: 0, y: 398, width: 128, height: 626
        }

        ,
        {
        id: 'wall_right_top', x: 1361, y: 114, width: 175, height: 284
        }

        ,
        {
        id: 'wall_right_main', x: 1428, y: 398, width: 108,
        height: 626
        }

        ,
        {
        id: 'wall_bottom', x: 0, y: 990, width: 1534, height: 34
        }

        ,

        // --- Buildings ---
            {
            id: 'building_left', x: 167, y: 151, width: 333, height: 338
        }

        ,
        {
        id: 'building_center', x: 519, y: 87, width: 499, height: 384
        }

        ,
        {
        id: 'building_right', x: 1037, y: 151, width: 333, height: 338
        }

        ,

        // --- Trees ---
            {
            id: 'tree_top_1', x: 190, y: 280, width: 180, height: 160
        }

        ,
        {
        id: 'tree_top_2', x: 380, y: 250, width: 180, height: 160
        }

        ,
        {
        id: 'tree_top_3', x: 678, y: 240, width: 180, height: 160
        }

        ,
        {
        id: 'tree_top_4', x: 960, y: 250, width: 180, height: 160
        }

        ,
        {
        id: 'tree_top_5', x: 1165, y: 280, width: 180, height: 160
        }

        ,
        {
        id: 'tree_left_1', x: 90, y: 340, width: 180, height: 160
        }

        ,
        {
        id: 'tree_left_2', x: 50, y: 520, width: 180, height: 160
        }

        ,
        {
        id: 'tree_left_3', x: 90, y: 700, width: 180, height: 160
        }

        ,
        {
        id: 'tree_right_1', x: 1185, y: 340, width: 180, height: 160
        }

        ,
        {
        id: 'tree_right_3', x: 1185, y: 640, width: 180, height: 160
        }

        ,
        {
        id: 'tree_bottom_1', x: 295, y: 780, width: 180, height: 160
        }

        ,
        {
        id: 'tree_bottom_3', x: 1060, y: 780, width: 180, height: 160
        }

        ];

        gameState.tutorialBoundaries=tutorialBoundaries;
        gameState.level1Boundaries=level1Boundaries;

        document.getElementById('save-button').addEventListener('click',
            saveGame);
        document.getElementById('load-button').addEventListener('click',
            () => location.reload());
        document.getElementById('new-game-button').addEventListener('click',
            newGame);
        startButton.addEventListener('click', startGame);

        document.addEventListener('click', startBackgroundMusic, {
            once: true
        });

        setInterval(saveGame, 180000);

        const assetsToLoad=[ startScreenImage, level1MapImage, playerImage, ratioImageL,
        ratioImageR,
        brokenGaryImage, garyWakeUpImage, fixedGaryIdleImage,
        cogImage, loomImage, chipImage, doorSpriteImage,
        doorOpenImage,
        doorClosedImage, snowflakeImage];
        let loadedCount=0;
        const totalAssets=assetsToLoad.length;

        const checkAllLoaded=() => {
            loadedCount++;

            if (loadedCount===totalAssets) {
                requestAnimationFrame(gameLoop);
            }
        }

        ;

        assetsToLoad.forEach(asset => {
                asset.onload=checkAllLoaded;

                asset.onerror=() => {
                    console.error(`Failed to load image: ${asset.src}`);
                    checkAllLoaded();
                }

                ;
            });
        }

        init();
        </script> </body> </html>