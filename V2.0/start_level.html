<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Academy</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script type="module">
        // This script is intentionally left blank.
        // The API key has been moved to a secure serverless function.
    </script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }
        .game-container {
            position: relative;
        }
        .game-console-body {
            background: linear-gradient(145deg, #3c3c3c, #1e1e1e);
            border-radius: 30px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            border: 2px solid #111;
            width: 100%;
            aspect-ratio: 1536 / 1024;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.7), 0 10px 30px rgba(0,10px,30px,0.5);
        }
        #canvas-header {
            color: #aaa;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        #game-canvas {
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            width: 100%;
            max-width: 1536px;
            height: auto;
            aspect-ratio: 1536 / 1024;
            background-color: #000;
        }
        #game-controls {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }
        .control-button {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 8px 16px;
            border-radius: 5px;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-button:hover {
            background-color: #444;
            border-color: #777;
        }
        #start-button {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 40px;
            font-size: 28px;
            font-family: 'Roboto Mono', monospace;
            background-color: rgba(10, 25, 40, 0.7);
            color: #a0e9ff;
            border: 2px solid #50c8e8;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(80, 200, 232, 0.5), inset 0 0 10px rgba(80, 200, 232, 0.3);
            text-shadow: 0 0 8px #50c8e8;
            display: block;
            letter-spacing: 2px;
        }
        #start-button:hover {
            background-color: rgba(20, 40, 60, 0.9);
            color: #ffffff;
            box-shadow: 0 0 25px rgba(80, 200, 232, 0.8), inset 0 0 15px rgba(80, 200, 232, 0.5);
            text-shadow: 0 0 12px #a0e9ff;
        }
        #save-feedback {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 255, 127, 0.8);
            color: #000;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="game-console-body">
            <div id="canvas-header">PROMPT ENGINEERING ACADEMY</div>
            <canvas id="game-canvas" width="1536" height="1024"></canvas>
            <div id="game-controls">
                <button id="save-button" class="control-button">Save Game</button>
                <button id="load-button" class="control-button">Load Last Save</button>
                <button id="new-game-button" class="control-button">New Game</button>
            </div>
        </div>
        <button id="start-button">START</button>
    </div>
    <div id="save-feedback"></div>

    <script type="module">
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('start-button');

        // --- TUNABLE CONSTANTS ---
        const PLAYER_SPEED = 135; 
        const RATIO_SPEED = 110;
        const DOOR_SCALE_FACTOR = 1.5; // Adjust this to make the door bigger or smaller (e.g., 1.2 is 20% bigger)
        const GARY_IDLE_FPS = 3; // Higher number = slower animation

        const PLAYER_DISPLAY_WIDTH = 60; 
        const PLAYER_DISPLAY_HEIGHT = 88; 
        const RATIO_DISPLAY_WIDTH = 42; 
        const RATIO_DISPLAY_HEIGHT = 44;
        const GROUNDSKEEPER_DISPLAY_WIDTH = 60; 
        const GROUNDSKEEPER_DISPLAY_HEIGHT = 78;

        let gameState = {
            gameMode: 'startScreen',
            transitionAlpha: 0,
            isAiThinking: false,
            leaves: [],
            player: { 
                x: 750, y: 800, spriteWidth: 164, spriteHeight: 243,
                width: PLAYER_DISPLAY_WIDTH, height: PLAYER_DISPLAY_HEIGHT,
                frameX: 0, frameY: 0, speed: PLAYER_SPEED, moving: false 
            },
            ratio: { 
                x: 0, y: 0, width: RATIO_DISPLAY_WIDTH, height: RATIO_DISPLAY_HEIGHT, 
                speed: RATIO_SPEED, followDistance: 90, direction: 'right', synced: false
            },
            keys: { w: false, a: false, s: false, d: false },
            nearbyObject: null,
            activeDialogue: {
                isActive: false, speaker: null, text: '', displayText: '',
                charIndex: 0, options: [], selectedOption: 0
            },
            tutorialState: {
                step: 0,
                ratioSyncStep: 0,
                doorOpen: false,
                dialogueHistory: [],
                controlsExplained: false,
            },
            level1State: {
                inventory: { cog: false, loom: false, chip: false },
                garyFixed: false,
                garyDialogueStep: 0,
                garyAnimationState: 'off', 
                garyAnimationFrame: 0,
                garyAnimationTimer: 0,
                levelComplete: false,
                completeMessageTimer: 0,
                dialogueHistory: [],
            },
            startScreenState: {
                finn: { x: 350, y: 750, targetX: 350, targetY: 750, pauseTimer: 99999, speed: 6, moving: false, frameY: 0 },
                ratio: { x: 1150, y: 780, targetX: 1150, targetY: 780, pauseTimer: 99999, speed: 6, moving: false },
                gary: { x: canvas.width / 1.21 - (GROUNDSKEEPER_DISPLAY_WIDTH * 1.8 / 2), y: 800, frame: 0, timer: 0 }
            },
            // New Boundary Properties
            showBoundaries: false, // Toggle visibility of boundaries
            boundaryThickness: 9, // Default visual thickness of boundaries
            tutorialBoundaryAdjustments: {
                tutorial_wall_left: { adjustX: 40, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
                tutorial_wall_right: { adjustX: -40, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
                tutorial_wall_top: { adjustX: 0, adjustY: 350, adjustWidth: 0, adjustHeight: 0 }, // Move top wall down by 100px
                tutorial_wall_bottom: { adjustX: 0, adjustY: 100, adjustWidth: 0, adjustHeight: 0 }
            },
            level1BoundaryAdjustments: {
            // Walls
            'wall_top': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'wall_left_top': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'wall_left_main': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'wall_right_top': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'wall_right_main': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'wall_bottom': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },

            // Buildings
            'building_left': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'building_center': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'building_right': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },

            // Top Trees
            'tree_top_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'tree_top_2': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'tree_top_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'tree_top_4': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'tree_top_5': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },

            // Left Trees
            'tree_left_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'tree_left_2': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            'tree_left_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },

            // Right Trees
            'tree_right_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            // 'tree_right_2' was removed to open path to bot
            'tree_right_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },

            // Bottom Trees
            'tree_bottom_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            // 'tree_bottom_2' was removed for spawn area
            'tree_bottom_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
            }
        };

        const DOOR_BASE_WIDTH = 1050 * DOOR_SCALE_FACTOR;
        const DOOR_BASE_HEIGHT = 1200 * DOOR_SCALE_FACTOR;

        const tutorialInteractables = [
            { id: 'ratio_start', name: 'Ratio', x: 750, y: 700, width: 35, height: 37 },
            { id: 'door', name: 'Academy Entrance', x: (1536 / 2) - (DOOR_BASE_WIDTH / 2), y: -700, width: DOOR_BASE_WIDTH, height: DOOR_BASE_HEIGHT },
        ];
        
        const level1Interactables = [
            { id: 'broken_gary', name: 'Deactivated GARY', x: 1380, y: 450, width: 60, height: 78 },
            { id: 'cog', name: 'Cognitive Cog', x: 750, y: 600, width: 20, height: 20 }, // Moved closer to center and loom
            { id: 'loom', name: 'Logic Loom', x: 800, y: 500, width: 20, height: 20 }, // Centered and closer
            { id: 'chip', name: 'Empathy Chip', x: 850, y: 600, width: 20, height: 20 }  // Moved closer to center and loom
        ];
        
        const startScreenImage = new Image();
        const level1MapImage = new Image();
        const playerImage = new Image();
        const ratioImageR = new Image();
        const ratioImageL = new Image();
        const brokenGaryImage = new Image();
        const garyWakeUpImage = new Image();
        const fixedGaryIdleImage = new Image();
        const cogImage = new Image();
        const loomImage = new Image();
        const chipImage = new Image();
        const doorSpriteImage = new Image();
        const doorOpenImage = new Image();
        const doorClosedImage = new Image();
        const snowflakeImage = new Image();
        
        startScreenImage.src = 'assets/start/start_background.png';
        level1MapImage.src = 'assets/start/level_1_background.png';
        playerImage.src = 'assets/start/walking_character_Finn.png';
        ratioImageR.src = 'assets/start/Ratio_R.png'; 
        ratioImageL.src = 'assets/start/Ratio_L.png';
        brokenGaryImage.src = 'assets/start/deactivated_gary.png';
        garyWakeUpImage.src = 'assets/start/GARY_Wake_Up_Sitting.png';
        fixedGaryIdleImage.src = 'assets/start/GARY_idle2.png';
        cogImage.src = 'assets/start/cognative_cog.png';
        loomImage.src = 'assets/start/logic_loom.png';
        chipImage.src = 'assets/start/empathy_chip.png';
        doorSpriteImage.src = 'assets/start/door_sprite.png';
        doorOpenImage.src = 'assets/start/door_open.png';
        doorClosedImage.src = 'assets/start/door_closed.png';
        snowflakeImage.src = 'assets/start/snowflake.png';
        
        const ratioPersona = {
            systemPrompt: `You are Ratio, an ancient, wise, and cryptic if cantankerous guide. You are leading a new student, the 'Cadet', through their first trial. Your goal is to guide them to sync with you, then open a mysterious door, and eventually fix a broken robot named GARY. Keep responses to 1-2 short, helpful sentences. Be encouraging but mysterious. Do not break character.`
        };

        const garyPersona = {
            systemPrompt: `You are GARY, the groundskeeper of the Prompt Academy. You were recently restored by a student. You are helpful and knowledgeable about the academy grounds. You are grateful to the student for restoring you. Keep your responses to 1-2 short, helpful sentences.`
        };
        
        function saveGame() {
            try {
                localStorage.setItem('meMyselfAiSave_v5', JSON.stringify(gameState));
                showSaveFeedback('Game Saved!');
            } catch (error) { console.error("Could not save game:", error); }
        }

        function loadGame() {
            try {
                const savedData = localStorage.getItem('meMyselfAiSave_v5');
                if (savedData) {
                    const loadedState = JSON.parse(savedData);
                    if (loadedState.gameMode && loadedState.gameMode !== 'startScreen') {
                        gameState = loadedState;
                        showSaveFeedback('Save data loaded!');
                    }
                }
            } catch (error) {
                console.error("Could not load game:", error);
                localStorage.removeItem('meMyselfAiSave_v5');
            }
        }
        
        function showSaveFeedback(message) {
            const feedbackElement = document.getElementById('save-feedback');
            if (!feedbackElement) return;

            feedbackElement.textContent = message;
            feedbackElement.style.opacity = 1;

            setTimeout(() => {
                feedbackElement.style.opacity = 0;
            }, 2000); // Show the message for 2 seconds
        }

        function newGame() {
            localStorage.removeItem('meMyselfAiSave_v5');
            location.reload();
        }

        function startDialogue(speaker, text, options = []) {
            const { activeDialogue } = gameState;
            activeDialogue.isActive = true;
            activeDialogue.speaker = speaker;
            activeDialogue.text = text;
            activeDialogue.displayText = '';
            activeDialogue.charIndex = options.length > 0 ? text.length : 0; // Immediately show full text if options are present
            activeDialogue.options = options;
            activeDialogue.selectedOption = 0;
        }

        function closeDialogue() {
            gameState.activeDialogue.isActive = false;
        }

        async function getRatioDialogue(prompt, callback = null) {
            if (gameState.isAiThinking) return;
            gameState.isAiThinking = true;
            startDialogue("Ratio", "...");

            const currentDialogueHistory = gameState.tutorialState.dialogueHistory;
            currentDialogueHistory.push({ role: 'user', content: prompt });
            
            try {
                const response = await fetch("/.netlify/functions/get-game-data", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        "messages": [ { role: "system", content: ratioPersona.systemPrompt }, ...currentDialogueHistory ],
                        "model": "llama-3.1-8b-instant"
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const data = await response.json();
                const fullResponse = data.choices[0]?.message?.content || "";
                
                // Since we are not streaming, we can't update the text progressively.
                // We will just set the full response at once.
                gameState.activeDialogue.text = fullResponse;
                gameState.activeDialogue.charIndex = 0; // Start the typing animation

                currentDialogueHistory.push({ role: 'assistant', content: fullResponse });

                if (callback) {
                    callback();
                }

            } catch (error) {
                console.error("API Error:", error);
                startDialogue("System", "Error: Ratio's connection is unstable.");
            } finally {
                gameState.isAiThinking = false;
            }
        }

        async function getGaryDialogue(prompt, callback = null) {
            if (gameState.isAiThinking) return;
            gameState.isAiThinking = true;
            startDialogue("GARY", "...");

            const currentDialogueHistory = gameState.level1State.dialogueHistory;
            currentDialogueHistory.push({ role: 'user', content: prompt });

            try {
                const response = await fetch("/.netlify/functions/get-game-data", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        "messages": [ { role: "system", content: garyPersona.systemPrompt }, ...currentDialogueHistory ],
                        "model": "llama-3.1-8b-instant"
                    })
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const data = await response.json();
                const fullResponse = data.choices[0]?.message?.content || "";

                gameState.activeDialogue.text = fullResponse;
                gameState.activeDialogue.charIndex = 0;

                currentDialogueHistory.push({ role: 'assistant', content: fullResponse });

                if (callback) {
                    callback();
                }

            } catch (error) {
                console.error("API Error:", error);
                startDialogue("System", "Error: GARY's connection is unstable.");
            } finally {
                gameState.isAiThinking = false;
            }
        }
        
        function handleInteraction() {
            const { nearbyObject, activeDialogue, tutorialState } = gameState;
            if (!nearbyObject || activeDialogue.isActive) return;

            const { id } = nearbyObject;

            if (gameState.gameMode === 'tutorial') {
                if (id === 'ratio_start' && !gameState.ratio.synced) {
                    handleRatioSyncInteraction();
                } else if (id === 'door' && gameState.ratio.synced && !tutorialState.doorOpen) {
                    startDialogue("Finn", "This... obstacle... seems to be a door, but it won't budge.", [
                        { text: "Try command: 'I order you to open!'", action: () => { 
                            startDialogue("Door", "*The door remains silent and unmoving.*", [{ text: "Continue", action: () => { 
                                getRatioDialogue("The user tried a direct command on the door and it failed. Explain that some entities need a persona, a role to play, before they can understand instructions. Hint that they should try giving the door a role.");
                            } }]); 
                        }},
                        { text: "Try query: 'Are you a door?'", action: () => { 
                            startDialogue("Door", "*A faint hum is the only response.*", [{ text: "Continue", action: () => { 
                                getRatioDialogue("The user tried a simple query on the door and it failed. Explain that some entities need a persona, a role to play, before they can understand instructions. Hint that they should try giving the door a role.");
                            } }]); 
                        }},
                        { text: "Try persona: 'Act as a door that is unlocked and open.'", action: () => { 
                            tutorialState.doorOpen = true; 
                            startDialogue("Door", "*With a deep groan, the ancient mechanism turns and the door swings open.*", [{ text: "Enter", action: closeDialogue }]); 
                            tutorialState.step = 4;
                            saveGame();
                        }},
                    ]);
                } else if (id === 'door' && tutorialState.doorOpen) {
                    gameState.gameMode = 'transitionToLevel1';
                    gameState.transitionAlpha = 0;
                }

            } else if (gameState.gameMode === 'level1') {
                 if (id === 'cog' || id === 'loom' || id === 'chip') {
                    if (!gameState.level1State.inventory[id]) {
                        gameState.level1State.inventory[id] = true;
                        getRatioDialogue(`The user just found the ${nearbyObject.name}. Congratulate them and remind them how many parts are left to find.`);
                    }
                } else if (id === 'broken_gary') {
                    if (gameState.level1State.garyFixed) {
                        getGaryDialogue("The user is talking to you after you have been fixed. Thank them again and offer to help.");
                    } else {
                        handleGaryInteraction();
                    }
                }
            }
        }
        
        function handleRatioSyncInteraction() {
            const { tutorialState } = gameState;
            switch(tutorialState.ratioSyncStep) {
                case 0:
                    startDialogue("Ratio", "You have arrived. Tell me, traveler, who are you?", [
                        { text: "I am a student, here to learn.", action: () => {
                            tutorialState.ratioSyncStep = 1;
                            getRatioDialogue("The user says they are a student here to learn. Respond with a cryptic but welcoming remark, then offer to sync minds.");
                        }},
                        { text: "I am... not sure why I'm here.", action: () => {
                             tutorialState.ratioSyncStep = 1;
                             getRatioDialogue("The user says they are not sure why they are here. Respond with a philosophical musing about purpose, then offer to help them find it by syncing.");
                        }}
                    ]);
                    break;
                case 1:
                    startDialogue("Ratio", "Our paths are intertwined, it seems. To truly see this world, our minds must align. Shall we synchronize?", [
                        { text: "Synchronize with Ratio.", action: () => {
                            gameState.ratio.synced = true;
                            tutorialState.step = 3;
                            gameState.ratio.x = gameState.player.x - 50;
                            gameState.ratio.y = gameState.player.y;
                            getRatioDialogue("The user agreed to sync. Welcome them and guide them towards the large door.");
                            closeDialogue();
                        }},
                        { text: "I'm not ready for that.", action: () => {
                            getRatioDialogue("The user is hesitant to sync. Reassure them that it is the only way forward.");
                            closeDialogue();
                        }}
                    ]);
                    break;
            }
        }

        function handleGaryInteraction() {
            const { level1State } = gameState;
            if (!level1State.inventory.cog || !level1State.inventory.loom || !level1State.inventory.chip) {
                getRatioDialogue("The player is trying to fix GARY but doesn't have all the parts yet.");
                return;
            }

            switch (level1State.garyDialogueStep) {
                case 0:
                    startDialogue("GARY", "*whirr...* Identity not found... State purpose...", [
                        { text: "We are here to help you find yourself.", action: () => { level1State.garyDialogueStep = 1; handleGaryInteraction(); }},
                        { text: "You're a machine. We need to pass.", action: () => { startDialogue("GARY", "Threat detected. Defensive protocols active. *BZZT*"); }},
                    ]);
                    break;
                case 1:
                     startDialogue("GARY", "To build a consciousness, what is the first foundation? Present the first module.", [
                        { text: "Install Cognitive Cog (To think)", action: () => { level1State.garyDialogueStep = 2; handleGaryInteraction(); }},
                        { text: "Install Logic Loom (To reason)", action: () => { startDialogue("GARY", "SEQUENCE ERROR. Reason without a mind is hollow. A thinking entity must first exist before it can reason.", () => { level1State.garyDialogueStep = 0; }); }},
                        { text: "Install Empathy Chip (To feel)", action: () => { startDialogue("GARY", "SEQUENCE ERROR. Feeling without thought is chaos. A thinking entity must first exist before it can feel.", () => { level1State.garyDialogueStep = 0; }); }}
                    ]);
                    break;
                case 2:
                     startDialogue("GARY", "I think, therefore I am... Acknowledged. A mind is formed. What gives it structure? Present the second module.", [
                        { text: "Install Logic Loom (To reason)", action: () => { level1State.garyDialogueStep = 3; handleGaryInteraction(); }},
                        { text: "Install Empathy Chip (To feel)", action: () => { startDialogue("GARY", "SEQUENCE ERROR. Empathy before logic invites overload. A thinking mind needs the structure of reason before it can process emotion.", () => { level1State.garyDialogueStep = 0; }); }}
                    ]);
                    break;
                case 3:
                    startDialogue("GARY", "Logic online. My thoughts have structure. What is the final piece to connect me? Present the final module.", [
                        { text: "Install Empathy Chip (To feel)", action: () => {
                            level1State.garyFixed = true;
                            level1State.garyAnimationState = 'wakingUp';
                            startDialogue("GARY", "I... understand. Thank you, Cadet. The Academy grounds are yours to explore. I shall be here if you need assistance.", [{ text: "Continue", action: () => {
                                level1State.levelComplete = true;
                                level1State.completeMessageTimer = 5;
                                saveGame();
                                closeDialogue();
                            }}]);
                        }}
                    ]);
                    break;
            }
        }
        
        function handleKeyDown(e) {
            const { gameMode, activeDialogue } = gameState;
            const key = e.key.toLowerCase();

            if (gameMode === 'startScreen' || gameMode.startsWith('transition')) return;
            
            if (activeDialogue.isActive) {
                if (key === 'w' || key === 'arrowup') {
                    activeDialogue.selectedOption = (activeDialogue.selectedOption - 1 + activeDialogue.options.length) % activeDialogue.options.length;
                } else if (key === 's' || key === 'arrowdown') {
                    activeDialogue.selectedOption = (activeDialogue.selectedOption + 1) % activeDialogue.options.length;
                } else if (key === 'e' || key === 'enter') {
                    if (activeDialogue.charIndex < activeDialogue.text.length) {
                        activeDialogue.charIndex = activeDialogue.text.length;
                    } else if (activeDialogue.options.length > 0) {
                        activeDialogue.options[activeDialogue.selectedOption].action();
                    } else {
                        closeDialogue();
                    }
                }
                return;
            }

            if (gameState.keys.hasOwnProperty(key)) {
                gameState.keys[key] = true;
                gameState.player.moving = true;
            }
            if (key === 'e') handleInteraction();
        }
        
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (gameState.keys.hasOwnProperty(key)) gameState.keys[key] = false;
            if (!gameState.keys.w && !gameState.keys.a && !gameState.keys.s && !gameState.keys.d) {
                gameState.player.moving = false;
            }
        });
        
        function startGame() {
            if (gameState.gameMode !== 'startScreen') return;
            gameState.gameMode = 'transitionToTutorial';
            startButton.style.display = 'none';
        }
        
        function checkCollision(rectA, rectB) {
            const buffer = 5; 
            return rectA.x < rectB.x + rectB.width + buffer && rectA.x + rectA.width + buffer > rectB.x &&
                   rectA.y < rectB.y + rectB.height + buffer && rectA.y + rectA.height + buffer > rectB.y;
        }

        function update(deltaTime) {
            const { gameMode } = gameState;
            
            handlePlayerAnimation(deltaTime);

            if (gameMode === 'startScreen') {
                updateStartScreenWander(gameState.startScreenState.finn, gameState.player);
                updateStartScreenWander(gameState.startScreenState.ratio);
                updateLeaves(deltaTime);
                updateGaryStartScreenAnimation(deltaTime);

            } else if (gameMode === 'transitionToTutorial' || gameMode === 'transitionToLevel1') {
                gameState.transitionAlpha += 2.0 * deltaTime;
                if (gameState.transitionAlpha >= 1) {
                    if (gameMode === 'transitionToLevel1') {
                        gameState.gameMode = 'level1';
                        gameState.player.x = canvas.width / 2;
                        gameState.player.y = canvas.height - 150;
                        gameState.ratio.x = gameState.player.x - 50;
                        gameState.ratio.y = gameState.player.y;
                    } else {
                        gameState.gameMode = 'tutorial';
                        gameState.player.x = canvas.width / 2;
                        gameState.player.y = canvas.height - 150;
                        gameState.ratio.x = tutorialInteractables.find(i => i.id === 'ratio_start').x;
                        gameState.ratio.y = tutorialInteractables.find(i => i.id === 'ratio_start').y;

                    }
                    gameState.transitionAlpha = 0;
                }

            } else if (gameMode === 'tutorial' || gameMode === 'level1') {
                if (!gameState.tutorialState.controlsExplained && gameMode === 'tutorial') {
                    startDialogue("Tutorial", "Use W/A/S/D keys to move your character. Press E to interact with objects and characters.", [
                        { text: "Got it!", action: () => {
                            gameState.tutorialState.controlsExplained = true;
                            closeDialogue();
                        }}
                    ]);
                    return; // Pause game update until dialogue is closed
                }

                if (gameState.activeDialogue.isActive) {
                    const { activeDialogue } = gameState;
                    if (activeDialogue.charIndex < activeDialogue.text.length) {
                        activeDialogue.charIndex += 30 * deltaTime;
                    }
                    gameState.player.moving = false;
                    return;
                }
                const { player, ratio, keys, tutorialState, level1State } = gameState;
                let moved = false;
                let newPlayerX = player.x;
                let newPlayerY = player.y;

                if (keys.w) { newPlayerY -= player.speed * deltaTime; player.frameY = 3; moved = true; }
                if (keys.s) { newPlayerY += player.speed * deltaTime; player.frameY = 0; moved = true; }
                if (keys.a) { newPlayerX -= player.speed * deltaTime; player.frameY = 2; ratio.direction = 'left'; moved = true; }
                if (keys.d) { newPlayerX += player.speed * deltaTime; player.frameY = 1; ratio.direction = 'right'; moved = true; }
                
                // Apply boundary collision detection
                const currentBoundaries = gameMode === 'tutorial' ? gameState.tutorialBoundaries : gameState.level1Boundaries;
                const currentAdjustments = gameMode === 'tutorial' ? gameState.tutorialBoundaryAdjustments : gameState.level1BoundaryAdjustments;

                let collisionDetected = false;
                for (const boundary of currentBoundaries) {
                    let { x, y, width, height } = boundary;
                    const adjustment = currentAdjustments[boundary.id];
                    if (adjustment) {
                        x += adjustment.adjustX;
                        y += adjustment.adjustY;
                        width += adjustment.adjustWidth;
                        height += adjustment.adjustHeight;
                    }

                    if (checkCollision({ x: newPlayerX, y: newPlayerY, width: player.width, height: player.height }, { x, y, width, height })) {
                        collisionDetected = true;
                        break;
                    }
                }

                if (!collisionDetected) {
                    player.x = newPlayerX;
                    player.y = newPlayerY;
                }

                if (moved) {
                    // tutorialState.controlsHintTimer = 0; // This was removed previously
                }

                player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
                player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
                
                if (ratio.synced) {
                    const dx = player.x - ratio.x; const dy = player.y - ratio.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance > ratio.followDistance) {
                        ratio.x += (dx / distance) * ratio.speed * deltaTime; ratio.y += (dy / distance) * ratio.speed * deltaTime;
                    }
                }
                
                gameState.nearbyObject = null;
                const currentInteractables = gameMode === 'tutorial' ? tutorialInteractables : level1Interactables;
                for (const obj of currentInteractables) {
                    if (gameMode === 'level1' && obj.id.match(/cog|loom|chip/) && level1State.inventory[obj.id]) continue;
                    if (checkCollision(player, obj)) { 
                        gameState.nearbyObject = obj; 
                        break; 
                    }
                }
                if (tutorialState.controlsHintTimer > 0) tutorialState.controlsHintTimer -= deltaTime;
                if (!ratio.synced && !gameState.activeDialogue.isActive && tutorialState.ratioSyncStep === 1) {
                    handleRatioSyncInteraction();
                }

                if (gameMode === 'level1') {
                    updateGaryAnimation(deltaTime);
                    if(level1State.completeMessageTimer > 0) {
                        level1State.completeMessageTimer -= deltaTime;
                    }
                }
            }
        }
        
        function updateStartScreenWander(character, deltaTime, playerChar = null) {
            if (character.pauseTimer > 0) {
                character.pauseTimer -= deltaTime;
                character.moving = false;
                if (playerChar) playerChar.moving = false;
                return;
            }

            character.moving = true;
            if (playerChar) playerChar.moving = true;

            const dx = character.targetX - character.x;
            const dy = character.targetY - character.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 5) {
                character.pauseTimer = Math.random() * 3 + 2;
                character.targetX = Math.random() * (canvas.width - 100);
                character.targetY = Math.random() * (canvas.height - 150) + 50;
                return;
            }

            character.x += (dx / dist) * character.speed * deltaTime;
            character.y += (dy / dist) * character.speed * deltaTime;

            if (playerChar) {
                if (dx > 0) playerChar.frameY = 1;
                else if (dx < 0) playerChar.frameY = 2;
            }
        }

        function updateLeaves(deltaTime) {
            if (gameState.leaves.length < 150) { // Ensure there are enough leaves
                createLeaves(150 - gameState.leaves.length);
            }
            for (const leaf of gameState.leaves) {
                leaf.y += leaf.speedY * 60 * deltaTime;
                leaf.x += leaf.speedX * 60 * deltaTime;
                leaf.rotation += leaf.rotationSpeed * 60 * deltaTime;
                
                if (leaf.y > canvas.height) {
                    leaf.y = -20;
                    leaf.x = Math.random() * canvas.width;
                    leaf.speedX = Math.sin(Math.random() * Math.PI * 2) * 0.2;
                    leaf.opacity = Math.random() * 0.5 + 0.3; // Reset opacity
                    leaf.size = Math.random() * 10 + 5; // Reset size
                    leaf.speedY = Math.random() * 0.5 + 0.2; // Reset speed
                }
            }
        }

        function updateGaryStartScreenAnimation(deltaTime) {
            const { gary } = gameState.startScreenState;
            gary.timer += deltaTime;
            if (gary.timer >= 1 / GARY_IDLE_FPS) {
                gary.timer = 0;
                gary.frame = (gary.frame + 1) % 3;
            }
        }

        function updateGaryAnimation(deltaTime) {
            const { level1State } = gameState;
            if (level1State.garyAnimationState === 'off') return;

            const WAKE_UP_FRAMES = 4;
            const STAND_UP_FRAMES = 5;
            const IDLE_FRAMES = 3;
            const WAKE_STAND_FPS = 5;

            level1State.garyAnimationTimer += deltaTime;

            switch (level1State.garyAnimationState) {
                case 'wakingUp':
                    if (level1State.garyAnimationTimer >= 1 / WAKE_STAND_FPS) {
                        level1State.garyAnimationTimer = 0;
                        level1State.garyAnimationFrame++;
                        if (level1State.garyAnimationFrame >= WAKE_UP_FRAMES) {
                            level1State.garyAnimationState = 'idle'; // Transition directly to idle
                            level1State.garyAnimationFrame = 0;
                        }
                    }
                    break;
                case 'idle':
                    if (level1State.garyAnimationTimer >= 1 / GARY_IDLE_FPS) {
                        level1State.garyAnimationTimer = 0;
                        level1State.garyAnimationFrame = (level1State.garyAnimationFrame + 1) % IDLE_FRAMES;
                    }
                    break;
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const { gameMode } = gameState;
            
            if (gameMode === 'startScreen') {
                drawStartScreen();
            } else if (gameMode.startsWith('transition')) {
                const bgImage = gameMode === 'transitionToLevel1' ? level1MapImage : doorClosedImage;
                if (bgImage.complete) ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
                ctx.fillStyle = `rgba(0, 0, 0, ${gameState.transitionAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

            } else if (gameMode === 'tutorial') {
                drawTutorial();
            } else if (gameMode === 'level1') {
                drawLevel1();
            }
        }
        
        function drawStartScreen() {
            if (startScreenImage.complete) ctx.drawImage(startScreenImage, 0, 0, canvas.width, canvas.height);
            
            drawLeaves();

            ctx.textAlign = 'center';
            ctx.font = '70px "Press Start 2P"';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 20;
            ctx.fillText("Prompt Academy", canvas.width / 2, 200);
            ctx.shadowBlur = 0;
            
            const { finn: startFinn, ratio: startRatio, gary: startGary } = gameState.startScreenState;
            const player = gameState.player;
            
            if (playerImage.complete) {
                const frameX = player.moving ? player.frameX : 0;
                ctx.drawImage(playerImage, frameX * player.spriteWidth, player.frameY * player.spriteHeight, 
                              player.spriteWidth, player.spriteHeight, startFinn.x, startFinn.y, PLAYER_DISPLAY_WIDTH, PLAYER_DISPLAY_HEIGHT);
            }
            if (ratioImageR.complete) ctx.drawImage(ratioImageR, startRatio.x, startRatio.y, RATIO_DISPLAY_WIDTH, RATIO_DISPLAY_HEIGHT);
            
            if (fixedGaryIdleImage.complete) {
                const frameHeight = fixedGaryIdleImage.height / 3;
                ctx.drawImage(fixedGaryIdleImage, 0, startGary.frame * frameHeight,
                              fixedGaryIdleImage.width, frameHeight,
                              startGary.x, startGary.y,
                              GROUNDSKEEPER_DISPLAY_WIDTH * 1.8, GROUNDSKEEPER_DISPLAY_HEIGHT * 1.8);
            }
        }

        function drawLeaves() {
            // ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Changed to white for snow
            for (const leaf of gameState.leaves) {
                // Calculate the new size, 50% bigger
                const drawSize = leaf.size * 2.5;

                ctx.save();
                ctx.translate(leaf.x, leaf.y);
                ctx.rotate(leaf.rotation * Math.PI / 180);
                
                if (snowflakeImage.complete && snowflakeImage.naturalWidth > 0) {
                    ctx.globalAlpha = leaf.opacity;
                    
                    // Use drawSize and ensure it's centered
                    ctx.drawImage(snowflakeImage, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    
                    ctx.globalAlpha = 1.0; // Reset global alpha
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Fallback
                    
                    // Use drawSize and fix centering. 
                    // (-drawSize / 2) makes the square's center align with the rotation point.
                    ctx.fillRect(-drawSize / 2, -drawSize / 2, drawSize, drawSize); // centered square for snow
                }
                
                ctx.restore();
            }
        }


        function drawTutorial() {
            const backgroundImage = gameState.tutorialState.doorOpen ? doorOpenImage : doorClosedImage;
            if (backgroundImage.complete) {
                ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
            }
            
            const { tutorialState, ratio, player } = gameState;

            let ratioDrawX = ratio.synced ? ratio.x : tutorialInteractables.find(i => i.id === 'ratio_start').x;
            let ratioDrawY = ratio.synced ? ratio.y : tutorialInteractables.find(i => i.id === 'ratio_start').y;
            const ratioImg = ratio.direction === 'left' ? ratioImageL : ratioImageR;
            if (ratioImg.complete) ctx.drawImage(ratioImg, ratioDrawX, ratioDrawY, ratio.width, ratio.height);

            if (playerImage.complete) ctx.drawImage( playerImage, player.frameX * player.spriteWidth, player.frameY * player.spriteHeight,
                    player.spriteWidth, player.spriteHeight, player.x, player.y, player.width, player.height );
            
            drawProgressionBar();
            drawHud();
            drawBoundaries(); // Draw boundaries after other elements
            if (gameState.activeDialogue.isActive) drawDialogueBox();
        }

        function drawLevel1() {
            if (level1MapImage.complete) ctx.drawImage(level1MapImage, 0, 0, canvas.width, canvas.height);
            
            const { level1State, player, ratio } = gameState;

            level1Interactables.forEach(obj => {
                if (obj.id.match(/cog|loom|chip/) && !level1State.inventory[obj.id]) {
                    let itemImage;
                    if (obj.id === 'cog') itemImage = cogImage;
                    else if (obj.id === 'loom') itemImage = loomImage;
                    else if (obj.id === 'chip') itemImage = chipImage;

                    if (itemImage && itemImage.complete) {
                         const pulse = Math.abs(Math.sin(Date.now() * 0.005));
                         ctx.globalAlpha = 0.8 + pulse * 0.2;
                         ctx.drawImage(itemImage, obj.x, obj.y, obj.width * 2.5, obj.height * 2.5);
                         ctx.globalAlpha = 1;
                    }
                }
            });

            drawGary();

            const ratioImg = ratio.direction === 'left' ? ratioImageL : ratioImageR;
            if (ratioImg.complete) ctx.drawImage(ratioImg, ratio.x, ratio.y, ratio.width, ratio.height);

            if (playerImage.complete) ctx.drawImage( playerImage, player.frameX * player.spriteWidth, player.frameY * player.spriteHeight,
                    player.spriteWidth, player.spriteHeight, player.x, player.y, player.width, player.height );
            
            drawProgressionBar();
            drawHud();
            drawBoundaries(); // Draw boundaries after other elements
            if (level1State.completeMessageTimer > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 80, canvas.width, 60);
                ctx.font = '40px "Press Start 2P"';
                ctx.fillStyle = '#00FFFF';
                ctx.textAlign = 'center';
                ctx.fillText("Level 1 Completed!", canvas.width / 2, 125);
            }
            if (gameState.activeDialogue.isActive) drawDialogueBox();
        }

        function drawGary() {
            const { level1State } = gameState;
            const garyInteractable = level1Interactables.find(i => i.id === 'broken_gary');
            const garyX = garyInteractable.x;
            const garyY = garyInteractable.y;
                        const garyWidth = garyInteractable.width * 1.35; 
                        const garyHeight = garyInteractable.height * 1.35;
            ctx.globalAlpha = 1;

            switch(level1State.garyAnimationState) {
                case 'off':
                    if (brokenGaryImage.complete) {
                        ctx.drawImage(brokenGaryImage, garyX, garyY, garyInteractable.width * 1.5, garyInteractable.height * 1.5);
                    }
                    break;
                case 'wakingUp':
                    if (garyWakeUpImage.complete) {
                        const frameHeight = garyWakeUpImage.height / 4;
                        ctx.drawImage(garyWakeUpImage, 0, level1State.garyAnimationFrame * frameHeight, garyWakeUpImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
                    }
                    break;
                case 'standingUp':
                     if (garyStandUpImage.complete) {
                        const frameHeight = garyStandUpImage.height / 5;
                        ctx.drawImage(garyStandUpImage, 0, level1State.garyAnimationFrame * frameHeight, garyStandUpImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
                    }
                    break;
                case 'idle':
                     if (fixedGaryIdleImage.complete) {
                        const frameHeight = fixedGaryIdleImage.height / 3;
                        ctx.drawImage(fixedGaryIdleImage, 0, level1State.garyAnimationFrame * frameHeight, fixedGaryIdleImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
                    }
                    break;
            }
        }

        let frameCounter = 0;
        const playerAnimationFPS = 10; // Animate at 10 frames per second
        function handlePlayerAnimation(deltaTime) {
            if (gameState.player.moving || (gameState.gameMode === 'startScreen' && gameState.startScreenState.finn.moving)) {
                frameCounter += deltaTime;
                if (frameCounter >= 1 / playerAnimationFPS) {
                    frameCounter = 0;
                    gameState.player.frameX = (gameState.player.frameX + 1) % 4;
                }
            } else {
                gameState.player.frameX = 0;
            }
        }

        function drawProgressionBar() {
            const barWidth = 400;
            const barHeight = 40;
            const barX = (canvas.width / 2) - (barWidth / 2);
            const barY = 20;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.strokeStyle = '#888';
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            ctx.font = '18px "Roboto Mono"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const inTutorial = gameState.gameMode === 'tutorial';
            const inLevel1 = gameState.gameMode === 'level1';

            ctx.fillStyle = inTutorial || inLevel1 ? '#00FFFF' : '#555';
            ctx.fillText("Tutorial", barX + (barWidth / 4), barY + barHeight / 2);

            ctx.fillStyle = '#888';
            ctx.fillText("-->", barX + (barWidth / 2), barY + barHeight / 2);

            ctx.fillStyle = inLevel1 ? '#00FFFF' : '#555';
            ctx.fillText("Level 1", barX + (barWidth * 3 / 4), barY + barHeight / 2);
        }

        function drawHud() {
            if (gameState.gameMode === 'level1') {
                const currentInventory = gameState.level1State.inventory;
                const invWidth = 350;
                const invHeight = 180;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; 
                ctx.fillRect(canvas.width - invWidth - 20, 20, invWidth, invHeight);
                ctx.strokeStyle = '#999'; 
                ctx.strokeRect(canvas.width - invWidth - 20, 20, invWidth, invHeight);
                
                ctx.fillStyle = '#FFF'; 
                ctx.font = '28px "Roboto Mono"'; 
                ctx.textAlign = 'left';
                ctx.fillText("INVENTORY", canvas.width - invWidth + 20, 65);

                ctx.font = '22px "Roboto Mono"'; 
                ctx.fillStyle = currentInventory.cog ? '#FFD700' : '#555';
                ctx.fillText("- Cognitive Cog", canvas.width - invWidth + 20, 105);
                ctx.fillStyle = currentInventory.loom ? '#00BFFF' : '#555';
                ctx.fillText("- Logic Loom", canvas.width - invWidth + 20, 135);
                ctx.fillStyle = currentInventory.chip ? '#FF69B4' : '#555';
                ctx.fillText("- Empathy Chip", canvas.width - invWidth + 20, 165);
            }

            if (!gameState.activeDialogue.isActive) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
                ctx.textAlign = 'center'; ctx.font = '22px "Roboto Mono"'; ctx.fillStyle = '#FFFFFF';
                if (gameState.nearbyObject) { 
                    const textPart1 = "Press ";
                    const textPart2 = "[E]";
                    const textPart3 = ` to interact with ${gameState.nearbyObject.name}`;

                    // Save current textAlign
                    const originalTextAlign = ctx.textAlign;
                    ctx.textAlign = 'left';

                    // Measure individual parts
                    const text1Width = ctx.measureText(textPart1).width;
                    const text2Width = ctx.measureText(textPart2).width;
                    const text3Width = ctx.measureText(textPart3).width;

                    // Calculate total width for centering the entire message
                    const totalWidth = text1Width + text2Width + text3Width;

                    // Calculate the starting X for the first part so the whole message is centered
                    let currentX = (canvas.width / 2) - (totalWidth / 2);

                    // Draw each part with its specific color
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(textPart1, currentX, canvas.height - 30);
                    currentX += text1Width;

                    ctx.fillStyle = '#FFFF00'; // Yellow for [E]
                    ctx.fillText(textPart2, currentX, canvas.height - 30);
                    currentX += text2Width;

                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillText(textPart3, currentX, canvas.height - 30);

                    // Restore original textAlign
                    ctx.textAlign = originalTextAlign;
                }
            }
        }

        function drawBoundaries() {
            if (!gameState.showBoundaries) return;

            const { gameMode, boundaryThickness, tutorialBoundaryAdjustments, level1BoundaryAdjustments } = gameState;
            let currentBoundaries = [];
            let currentAdjustments = {};

            if (gameMode === 'tutorial') {
                currentBoundaries = gameState.tutorialBoundaries;
                currentAdjustments = tutorialBoundaryAdjustments;
            } else if (gameMode === 'level1') {
                currentBoundaries = gameState.level1Boundaries;
                currentAdjustments = level1BoundaryAdjustments;
            }

            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; // Red, semi-transparent for visibility

            currentBoundaries.forEach(boundary => {
                let { x, y, width, height } = boundary;

                // Apply adjustments based on boundary ID
                const adjustment = currentAdjustments[boundary.id];
                if (adjustment) {
                    x += adjustment.adjustX;
                    y += adjustment.adjustY;
                    width += adjustment.adjustWidth;
                    height += adjustment.adjustHeight;
                }

                ctx.fillRect(x, y, width, height);
            });
        }

        function drawDialogueBox() {
            const { activeDialogue } = gameState;
            activeDialogue.displayText = activeDialogue.text.substring(0, activeDialogue.charIndex);

            const boxHeight = 200;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)'; ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2;
            ctx.fillRect(20, canvas.height - boxHeight - 20, canvas.width - 40, boxHeight);
            ctx.strokeRect(20, canvas.height - boxHeight - 20, canvas.width - 40, boxHeight);

            ctx.fillStyle = '#FFF'; ctx.font = 'bold 20px "Roboto Mono"'; ctx.textAlign = 'left';
            ctx.fillText(activeDialogue.speaker, 140, canvas.height - boxHeight);
            
            if (activeDialogue.speaker === "Ratio" && ratioImageR.complete) {
                ctx.fillStyle = '#111';
                ctx.fillRect(35, canvas.height - boxHeight - 5, 80, 80);
                ctx.drawImage(ratioImageR, 40, canvas.height - boxHeight, 70, 70);
            }
            
            ctx.font = 'bold 22px "Roboto Mono"';
            ctx.fillStyle = '#99FF99';
            ctx.shadowColor = "black";
            ctx.shadowBlur = 4;
            
            const lines = wrapText(activeDialogue.displayText, 90);
            lines.forEach((line, index) => {
                ctx.fillText(line, 145, canvas.height - boxHeight + 45 + (index * 30));
            });

            if (activeDialogue.charIndex >= activeDialogue.text.length) {
                if(activeDialogue.options.length > 0) {
                    activeDialogue.options.forEach((option, index) => {
                        ctx.fillStyle = index === activeDialogue.selectedOption ? '#FFFF00' : '#99FF99';
                        ctx.fillText(`${index === activeDialogue.selectedOption ? '> ' : ''}${option.text}`, 50, canvas.height - boxHeight + 110 + (index * 30));
                    });
                } else {
                    ctx.fillStyle = '#FFFF00'; // Changed to yellow
                    ctx.fillText("Press [E] to continue...", canvas.width - 450, canvas.height - 40);
                }
            }
            ctx.shadowBlur = 0;
        }
        
        function wrapText(text, maxWidthChars) {
            const words = text.split(' ');
            let lines = []; let currentLine = words[0] || '';
            for (let i = 1; i < words.length; i++) {
                if ((currentLine + ' ' + words[i]).length > maxWidthChars) {
                    lines.push(currentLine); currentLine = words[i];
                } else { currentLine += ' ' + words[i]; }
            }
            lines.push(currentLine); return lines;
        }

        function createLeaves(count = 150) {
            for (let i = 0; i < count; i++) {
                gameState.leaves.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 10 + 5,
                    speedY: Math.random() * 0.5 + 0.2,
                    speedX: Math.sin(Math.random() * Math.PI * 2) * 0.2,
                    rotation: Math.random() * 360,
                    rotationSpeed: (Math.random() - 0.5) * 2,
                    opacity: Math.random() * 0.5 + 0.3
                });
            }
        }

        let lastTime = 0;
        function gameLoop(time) {
            if (lastTime > 0) {
                const deltaTime = (time - lastTime) / 1000; // Delta time in seconds
                update(deltaTime);
            }
            lastTime = time;
            draw();
            requestAnimationFrame(gameLoop);
        }

        function init() {
            loadGame(); 
            createLeaves();
            
            // Level Boundaries - Defined here to ensure canvas.width and canvas.height are available
            const tutorialBoundaries = [
                // Left wall
                { id: 'tutorial_wall_left', x: 0, y: 0, width: 600, height: canvas.height },
                // Right wall
                { id: 'tutorial_wall_right', x: 950, y: 0, width: 600, height: canvas.height },
                // Top wall (above door)
                { id: 'tutorial_wall_top', x: 0, y: 0, width: canvas.width, height: 200 },
                // Bottom wall (below playable area)
                { id: 'tutorial_wall_bottom', x: 0, y: canvas.height - 100, width: canvas.width, height: 100 }
            ];
            const level1Boundaries = [
                // --- Outer Walls ---
                // Top wall (covers spires and top edge) - MODIFIED
                { id: 'wall_top', x: 0, y: 0, width: 1536, height: 57 },
                // Left wall (top section)
                { id: 'wall_left_top', x: 0, y: 114, width: 205, height: 284 },
                // Left wall (main section)
                { id: 'wall_left_main', x: 0, y: 398, width: 128, height: 626 },
                // Right wall (top section) - MODIFIED
                { id: 'wall_right_top', x: 1361, y: 114, width: 175, height: 284 },
                // Right wall (main section) - MODIFIED
                { id: 'wall_right_main', x: 1428, y: 398, width: 108, height: 626 },
                // Bottom wall (entire strip) - MODIFIED
                { id: 'wall_bottom', x: 0, y: 990, width: 1536, height: 34 },

                // --- Buildings ---
                // Left Building - MODIFIED (Moved down, 30% bigger)
                { id: 'building_left', x: 167, y: 151, width: 333, height: 338 },
                // Center Building - MODIFIED (Moved up)
                { id: 'building_center', x: 519, y: 87, width: 499, height: 384 },
                // Right Building - MODIFIED (Moved down, 30% bigger)
                { id: 'building_right', x: 1037, y: 151, width: 333, height: 338 },

                // --- Trees (Trunks) ---
                // Standard size for trunks (adjust as needed)
                // { id: 'tree_template', x: 0, y: 0, width: 51, height: 34 }

                // Top Row (5 trees) - MODIFIED
                { id: 'tree_top_1', x: 190, y: 280, width: 180, height: 160 },
                { id: 'tree_top_2', x: 380, y: 250, width: 180, height: 160 },
                { id: 'tree_top_3', x: 678, y: 240, width: 180, height: 160 },
                { id: 'tree_top_4', x: 960, y: 250, width: 180, height: 160 },
                { id: 'tree_top_5', x: 1165, y: 280, width: 180, height: 160 },

                // Left Row (3 trees) - MODIFIED
                { id: 'tree_left_1', x: 90, y: 340, width: 180, height: 160 },
                { id: 'tree_left_2', x: 50, y: 520, width: 180, height: 160 },
                { id: 'tree_left_3', x: 90, y: 700, width: 180, height: 160 },

                // Right Row (3 trees) - MODIFIED
                { id: 'tree_right_1', x: 1185, y: 340, width: 180, height: 160 },
                // { id: 'tree_right_2', x: 1225, y: 520, width: 180, height: 160 }, // <-- REMOVED to open path
                { id: 'tree_right_3', x: 1185, y: 640, width: 180, height: 160 }, // <-- Moved down from y: 520

                // Bottom Row (3 trees) - MODIFIED
                { id: 'tree_bottom_1', x: 295, y: 780, width: 180, height: 160 },
                // { id: 'tree_bottom_2', x: 678, y: 790, width: 180, height: 160 }, // <-- REMOVED for spawn
                { id: 'tree_bottom_3', x: 1060, y: 780, width: 180, height: 160 },
            ];



            // Assign to gameState for access in other functions
            gameState.tutorialBoundaries = tutorialBoundaries;
            gameState.level1Boundaries = level1Boundaries;
            
            document.getElementById('save-button').addEventListener('click', saveGame);
            document.getElementById('load-button').addEventListener('click', () => location.reload());
            document.getElementById('new-game-button').addEventListener('click', newGame);
            startButton.addEventListener('click', startGame);
            
            setInterval(saveGame, 180000);
            
            const assetsToLoad = [
                startScreenImage, level1MapImage, playerImage, ratioImageL, ratioImageR,
                brokenGaryImage, garyWakeUpImage, fixedGaryIdleImage,
                cogImage, loomImage, chipImage, doorSpriteImage, doorOpenImage, doorClosedImage,
                snowflakeImage
            ];
            let loadedCount = 0;
            const totalAssets = assetsToLoad.length;

            const checkAllLoaded = () => {
                loadedCount++;
                if (loadedCount === totalAssets) {
                    requestAnimationFrame(gameLoop);
                }
            };

            assetsToLoad.forEach(asset => {
                asset.onload = checkAllLoaded;
                asset.onerror = () => {
                    console.error(`Failed to load image: ${asset.src}`);
                    checkAllLoaded();
                };
            });
        }

        init();
    </script>
</body>
</html>


