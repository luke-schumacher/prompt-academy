<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompt Academy - Game Prototype</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            overflow: hidden;
        }
        .game-container {
            position: relative;
        }
        .game-console-body {
            background: linear-gradient(145deg, #3c3c3c, #1e1e1e);
            border-radius: 30px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            border: 2px solid #111;
            width: 100%;
            aspect-ratio: 1536 / 1024;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.7), 0 10px 30px rgba(0,10px,30px,0.5);
        }
        #canvas-header {
            color: #aaa;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        #game-canvas {
            border: 2px solid #4a4a4a;
            border-radius: 8px;
            width: 100%;
            max-width: 1536px;
            height: auto;
            aspect-ratio: 1536 / 1024;
            background-color: #000;
        }
        #game-controls {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
        }
        .control-button {
            background-color: #333;
            border: 1px solid #555;
            color: #eee;
            padding: 8px 16px;
            border-radius: 5px;
            font-family: 'Roboto Mono', monospace;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-button:hover {
            background-color: #444;
            border-color: #777;
        }
        #start-button {
            position: absolute;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);
            padding: 20px 40px;
            font-size: 28px;
            font-family: 'Roboto Mono', monospace;
            background-color: rgba(10, 25, 40, 0.7);
            color: #a0e9ff;
            border: 2px solid #50c8e8;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(80, 200, 232, 0.5), inset 0 0 10px rgba(80, 200, 232, 0.3);
            text-shadow: 0 0 8px #50c8e8;
            display: block;
            letter-spacing: 2px;
        }
        #start-button:hover {
            background-color: rgba(20, 40, 60, 0.9);
            color: #ffffff;
            box-shadow: 0 0 25px rgba(80, 200, 232, 0.8), inset 0 0 15px rgba(80, 200, 232, 0.5);
            text-shadow: 0 0 12px #a0e9ff;
        }
        #save-feedback {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 255, 127, 0.8);
            color: #000;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="game-console-body">
            <div id="canvas-header">PROMPT ENGINEERING ACADEMY</div>
            <canvas id="game-canvas" width="1536" height="1024"></canvas>
            <div id="game-controls">
                <button id="save-button" class="control-button">Save Game</button>
                <button id="load-button" class="control-button">Load Last Save</button>
                <button id="new-game-button" class="control-button">New Game</button>
                <button id="main-menu-button" class="control-button">Reset to Bio-Dome</button>
            </div>
        </div>
        <button id="start-button">START</button>
    </div>
    <div id="save-feedback"></div>

    <script type="module">
        const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const startButton = document.getElementById('start-button');

// --- TUNABLE CONSTANTS ---
const PLAYER_SPEED = 135;
const RATIO_SPEED = 110;
const DOOR_SCALE_FACTOR = 1.5;
const GARY_IDLE_FPS = 3;

const PLAYER_DISPLAY_WIDTH = 60;
const PLAYER_DISPLAY_HEIGHT = 88;
const RATIO_DISPLAY_WIDTH = 42;
const RATIO_DISPLAY_HEIGHT = 44;
const GROUNDSKEEPER_DISPLAY_WIDTH = 60;
const GROUNDSKEEPER_DISPLAY_HEIGHT = 78;

let gameState = {
    gameMode: 'startScreen',
    transitionAlpha: 0,
    isAiThinking: false,
    leaves: [],
    player: {
        x: 750, y: 800, spriteWidth: 164, spriteHeight: 243,
        width: PLAYER_DISPLAY_WIDTH, height: PLAYER_DISPLAY_HEIGHT,
        frameX: 0, frameY: 0, speed: PLAYER_SPEED, moving: false
    },
    ratio: {
        x: 0, y: 0, width: RATIO_DISPLAY_WIDTH, height: RATIO_DISPLAY_HEIGHT,
        speed: RATIO_SPEED, followDistance: 90, direction: 'right', synced: false
    },
    keys: { w: false, a: false, s: false, d: false },
    nearbyObject: null,
    activeDialogue: {
        isActive: false, speaker: null, text: '', displayText: '',
        charIndex: 0, options: [], selectedOption: 0
    },
    tutorialState: {
        step: 0,
        ratioSyncStep: 0,
        doorOpen: false,
        dialogueHistory: [],
        controlsExplained: false,
    },
    level1State: {
        inventory: { cog: false, loom: false, chip: false },
        garyFixed: false,
        garyDialogueStep: 0,
        garyAnimationState: 'off',
        garyAnimationFrame: 0,
        garyAnimationTimer: 0,
        levelComplete: false,
        completeMessageTimer: 0,
        dialogueHistory: [],
    },
    ecologyState: {
        introDone: false,
        bioBotMetStep: 0,
        visitedTerraVault: false,
        currentStage: 0,
        selectedWords: { first: null, second: null },
        currentSelection: 'first',
        bioBotMood: 'happy',
        mistakes: 0,
        levelComplete: false,
        completeMessageTimer: 0,
        dialogueHistory: [],
        showTerraVaultButton: false,
        showPromptInterface: false,
        promptInterfaceAlpha: 0,
        showSpeciesSelection: false,
        speciesSelectionIndex: 0,
        bioBotBobOffset: 0,
        holoBloomInfoRead: false,
    },
    resonanceState: {
        isActive: false,
        currentPiece: null,
        pattern: [],
        patternDisplay: [],
        currentIndex: 0,
        pulseTimer: 0,
        pulseDuration: 1.0,
        successCount: 0,
        requiredSuccess: 0,
        feedbackTimer: 0,
        lastCorrect: null,
        syncProgress: 0,
        particles: []
    },
    startScreenState: {
        finn: { x: 350, y: 750, targetX: 350, targetY: 750, pauseTimer: 99999, speed: 6, moving: false, frameY: 0 },
        ratio: { x: 1150, y: 780, targetX: 1150, targetY: 780, pauseTimer: 99999, speed: 6, moving: false },
        gary: { x: canvas.width / 1.21 - (GROUNDSKEEPER_DISPLAY_WIDTH * 1.8 / 2), y: 800, frame: 0, timer: 0 }
    },
    showBoundaries: false,
    boundaryThickness: 9,
    tutorialBoundaryAdjustments: {
        tutorial_wall_left: { adjustX: 40, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        tutorial_wall_right: { adjustX: -40, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        tutorial_wall_top: { adjustX: 0, adjustY: 350, adjustWidth: 0, adjustHeight: 0 },
        tutorial_wall_bottom: { adjustX: 0, adjustY: 100, adjustWidth: 0, adjustHeight: 0 }
    },
    level1BoundaryAdjustments: {
        'wall_top': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'wall_left_top': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'wall_left_main': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'wall_right_top': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'wall_right_main': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'wall_bottom': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'building_left': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'building_center': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'building_right': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_top_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_top_2': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_top_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_top_4': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_top_5': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_left_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_left_2': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_left_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_right_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_right_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_bottom_1': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
        'tree_bottom_3': { adjustX: 0, adjustY: 0, adjustWidth: 0, adjustHeight: 0 },
    }
};

const DOOR_BASE_WIDTH = 1050 * DOOR_SCALE_FACTOR;
const DOOR_BASE_HEIGHT = 1200 * DOOR_SCALE_FACTOR;

const tutorialInteractables = [
    { id: 'ratio_start', name: 'Ratio', x: 750, y: 700, width: 35, height: 37 },
    { id: 'door', name: 'Academy Entrance', x: (1536 / 2) - (DOOR_BASE_WIDTH / 2), y: -700, width: DOOR_BASE_WIDTH, height: DOOR_BASE_HEIGHT },
];

const level1Interactables = [
    { id: 'broken_gary', name: 'Deactivated GARY', x: 1380, y: 450, width: 60, height: 78 },
    { id: 'cog', name: 'Cognitive Cog', x: 750, y: 600, width: 20, height: 20 },
    { id: 'loom', name: 'Logic Loom', x: 800, y: 500, width: 20, height: 20 },
    { id: 'chip', name: 'Empathy Chip', x: 850, y: 600, width: 20, height: 20 }
];

const startScreenImage = new Image();
const level1MapImage = new Image();
const playerImage = new Image();
const ratioImageR = new Image();
const ratioImageL = new Image();
const brokenGaryImage = new Image();
const garyWakeUpImage = new Image();
const fixedGaryIdleImage = new Image();
const cogImage = new Image();
const loomImage = new Image();
const chipImage = new Image();
const doorSpriteImage = new Image();
const doorOpenImage = new Image();
const doorClosedImage = new Image();
const snowflakeImage = new Image();

startScreenImage.src = 'assets/start/start_background.png';
level1MapImage.src = 'assets/start/level_1_background.png';
playerImage.src = 'assets/start/walking_character_Finn.png';
ratioImageR.src = 'assets/start/Ratio_R.png';
ratioImageL.src = 'assets/start/Ratio_L.png';
brokenGaryImage.src = 'assets/start/deactivated_gary.png';
garyWakeUpImage.src = 'assets/start/GARY_Wake_Up_Sitting.png';
fixedGaryIdleImage.src = 'assets/start/GARY_idle2.png';
cogImage.src = 'assets/start/cognative_cog.png';
loomImage.src = 'assets/start/logic_loom.png';
chipImage.src = 'assets/start/empathy_chip.png';
doorSpriteImage.src = 'assets/start/door_sprite.png';
doorOpenImage.src = 'assets/start/door_open.png';
doorClosedImage.src = 'assets/start/door_closed.png';
snowflakeImage.src = 'assets/start/snowflake.png';

const ratioPersona = {
    systemPrompt: `You are Ratio, an ancient, wise, and cryptic if cantankerous guide. You are leading a new student, the 'Cadet', through their first trial. Your goal is to guide them to sync with you, then open a mysterious door, and eventually fix a broken robot named GARY. Keep responses to 1-2 short, helpful sentences. Be encouraging but mysterious. Do not break character.`
};

const garyPersona = {
    systemPrompt: `You are GARY, the groundskeeper of the Prompt Academy. You were recently restored by a student. You are helpful and knowledgeable about the academy grounds. You are grateful to the student for restoring you. Keep your responses to 1-2 short, helpful sentences.`
};

const resonancePatterns = {
    cog: {
        pattern: ['w', 'w', 's', 's', 'w', 'w'],
        display: ['↑', '↑', '↓', '↓', '↑', '↑'],
        pulseDuration: 0.8,
        color: '#FFD700',
        name: 'Cognitive Cog',
        description: 'Match the rhythm of thought...'
    },
    loom: {
        pattern: ['w', 'a', 's', 'd', 'w', 'a', 's', 'd'],
        display: ['↑', '←', '↓', '→', '↑', '←', '↓', '→'],
        pulseDuration: 0.6,
        color: '#00BFFF',
        name: 'Logic Loom',
        description: 'Follow the logical sequence...'
    },
    chip: {
        pattern: ['w', 'd', 's', 'a', 'w', 'd', 's', 'a'],
        display: ['↑', '→', '↓', '←', '↑', '→', '↓', '←'],
        pulseDuration: 0.7,
        color: '#FF69B4',
        name: 'Empathy Chip',
        description: 'Feel the emotional resonance...'
    }
};

function saveGame() {
    try {
        localStorage.setItem('meMyselfAiSave_v5', JSON.stringify(gameState));
        showSaveFeedback('Game Saved!');
    } catch (error) { console.error("Could not save game:", error); }
}

function loadGame() {
    try {
        const savedData = localStorage.getItem('meMyselfAiSave_v5');
        if (savedData) {
            const loadedState = JSON.parse(savedData);
            if (loadedState.gameMode && loadedState.gameMode !== 'startScreen') {
                gameState = loadedState;
                showSaveFeedback('Save data loaded!');
            }
        }
    } catch (error) {
        console.error("Could not load game:", error);
        localStorage.removeItem('meMyselfAiSave_v5');
    }
}

function showSaveFeedback(message) {
    const feedbackElement = document.getElementById('save-feedback');
    if (!feedbackElement) return;

    feedbackElement.textContent = message;
    feedbackElement.style.opacity = 1;

    setTimeout(() => {
        feedbackElement.style.opacity = 0;
    }, 2000);
}

function newGame() {
    localStorage.removeItem('meMyselfAiSave_v5');
    location.reload();
}

function startDialogue(speaker, text, options = []) {
    const { activeDialogue } = gameState;
    activeDialogue.isActive = true;
    activeDialogue.speaker = speaker;
    activeDialogue.text = text;
    activeDialogue.displayText = '';
    activeDialogue.charIndex = options.length > 0 ? text.length : 0;
    activeDialogue.options = options;
    activeDialogue.selectedOption = 0;
}

function closeDialogue() {
    gameState.activeDialogue.isActive = false;
}

function startResonanceTuning(pieceType) {
    const pattern = resonancePatterns[pieceType];
    if (!pattern) return;

    const { resonanceState } = gameState;
    resonanceState.isActive = true;
    resonanceState.currentPiece = pieceType;
    resonanceState.pattern = pattern.pattern;
    resonanceState.patternDisplay = pattern.display;
    resonanceState.pulseDuration = pattern.pulseDuration;
    resonanceState.currentIndex = 0;
    resonanceState.pulseTimer = 0;
    resonanceState.successCount = 0;
    resonanceState.requiredSuccess = pattern.pattern.length;
    resonanceState.feedbackTimer = 0;
    resonanceState.lastCorrect = null;
    resonanceState.syncProgress = 0;
    resonanceState.particles = [];
}

function endResonanceTuning(success) {
    const { resonanceState, level1State } = gameState;

    if (success) {
        level1State.inventory[resonanceState.currentPiece] = true;
        getRatioDialogue(`The player successfully attuned to the ${resonancePatterns[resonanceState.currentPiece].name}. Congratulate them and remind them how many parts are left to find.`);
    }

    resonanceState.isActive = false;
    resonanceState.currentPiece = null;
    resonanceState.pattern = [];
    resonanceState.patternDisplay = [];
    resonanceState.currentIndex = 0;
    resonanceState.syncProgress = 0;
    resonanceState.particles = [];
}

async function getRatioDialogue(prompt, callback = null) {
    if (gameState.isAiThinking) return;
    gameState.isAiThinking = true;
    startDialogue("Ratio", "...");

    const currentDialogueHistory = gameState.tutorialState.dialogueHistory;
    currentDialogueHistory.push({ role: 'user', content: prompt });

    try {
        const response = await fetch("/.netlify/functions/get-game-data", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                "messages": [ { role: "system", content: ratioPersona.systemPrompt }, ...currentDialogueHistory ],
                "model": "llama-3.1-8b-instant"
            })
        });

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
        }

        const data = await response.json();
        const fullResponse = data.choices[0]?.message?.content || "";

        gameState.activeDialogue.text = fullResponse;
        gameState.activeDialogue.charIndex = 0;

        currentDialogueHistory.push({ role: 'assistant', content: fullResponse });

        passApiDataToEcology(data);

        if (callback) {
            callback();
        }

    } catch (error) {
        console.error("API Error:", error);
        startDialogue("System", "Error: Ratio's connection is unstable.");
    } finally {
        gameState.isAiThinking = false;
    }
}

async function getGaryDialogue(prompt, callback = null) {
    if (gameState.isAiThinking) return;
    gameState.isAiThinking = true;
    startDialogue("GARY", "...");

    const currentDialogueHistory = gameState.level1State.dialogueHistory;
    currentDialogueHistory.push({ role: 'user', content: prompt });

    try {
        const response = await fetch("/.netlify/functions/get-game-data", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                "messages": [ { role: "system", content: garyPersona.systemPrompt }, ...currentDialogueHistory ],
                "model": "llama-3.1-8b-instant"
            })
        });

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
        }

        const data = await response.json();
        const fullResponse = data.choices[0]?.message?.content || "";

        gameState.activeDialogue.text = fullResponse;
        gameState.activeDialogue.charIndex = 0;

        currentDialogueHistory.push({ role: 'assistant', content: fullResponse });

        passApiDataToEcology(data);

        if (callback) {
            callback();
        }

    } catch (error) {
        console.error("API Error:", error);
        startDialogue("System", "Error: GARY's connection is unstable.");
    } finally {
        gameState.isAiThinking = false;
    }
}

function handleInteraction() {
    const { nearbyObject, activeDialogue, tutorialState } = gameState;
    if (!nearbyObject || activeDialogue.isActive) return;

    const { id } = nearbyObject;

    if (gameState.gameMode === 'tutorial') {
        if (id === 'ratio_start' && !gameState.ratio.synced) {
            handleRatioSyncInteraction();
        } else if (id === 'door' && gameState.ratio.synced && !tutorialState.doorOpen) {
            startDialogue("Finn", "This... obstacle... seems to be a door, but it won't budge.", [
                { text: "Try command: 'I order you to open!'", action: () => {
                    startDialogue("Door", "*The door remains silent and unmoving.*", [{ text: "Continue", action: () => {
                        getRatioDialogue("The user tried a direct command on the door and it failed. Explain that some entities need a persona, a role to play, before they can understand instructions. Hint that they should try giving the door a role.");
                    } }]);
                }},
                { text: "Try query: 'Are you a door?'", action: () => {
                    startDialogue("Door", "*A faint hum is the only response.*", [{ text: "Continue", action: () => {
                        getRatioDialogue("The user tried a simple query on the door and it failed. Explain that some entities need a persona, a role to play, before they can understand instructions. Hint that they should try giving the door a role.");
                    } }]);
                }},
                { text: "Try persona: 'Act as a door that is unlocked and open.'", action: () => {
                    tutorialState.doorOpen = true;
                    startDialogue("Door", "*With a deep groan, the ancient mechanism turns and the door swings open.*", [{ text: "Enter", action: closeDialogue }]);
                    tutorialState.step = 4;
                    saveGame();
                }},
            ]);
        } else if (id === 'door' && tutorialState.doorOpen) {
            gameState.gameMode = 'transitionToLevel1';
            gameState.transitionAlpha = 1;
            gameState.player.x = canvas.width / 2;
            gameState.player.y = canvas.height - 150;
            gameState.ratio.x = gameState.player.x - 50;
            gameState.ratio.y = gameState.player.y;
        }

    } else if (gameState.gameMode === 'level1') {
         if (id === 'ecology_door') {
            startDialogue("Ratio", "Ready to explore the Bio-Dome?", [
                { text: "Yes, let's go", action: () => {
                    closeDialogue();
                    goToEcologyLevel();
                }},
                { text: "Not yet", action: closeDialogue }
            ]);
        } else if (id === 'cog' || id === 'loom' || id === 'chip') {
            if (!gameState.level1State.inventory[id]) {
                startResonanceTuning(id);
            }
        } else if (id === 'broken_gary') {
            if (gameState.level1State.garyFixed) {
                getGaryDialogue("The user is talking to you after you have been fixed. Thank them again and offer to help.");
            } else {
                handleGaryInteraction();
            }
        }
    }
}

function handleRatioSyncInteraction() {
    const { tutorialState } = gameState;
    switch(tutorialState.ratioSyncStep) {
        case 0:
            startDialogue("Ratio", "You have arrived. Tell me, traveler, who are you?", [
                { text: "I am a student, here to learn.", action: () => {
                    tutorialState.ratioSyncStep = 1;
                    getRatioDialogue("The user says they are a student here to learn. Respond with a cryptic but welcoming remark, then offer to sync minds.");
                }},
                { text: "I am... not sure why I'm here.", action: () => {
                     tutorialState.ratioSyncStep = 1;
                     getRatioDialogue("The user says they are not sure why they are here. Respond with a philosophical musing about purpose, then offer to help them find it by syncing.");
                }}
            ]);
            break;
        case 1:
            startDialogue("Ratio", "Our paths are intertwined, it seems. To truly see this world, our minds must align. Shall we synchronize?", [
                { text: "Synchronize with Ratio.", action: () => {
                    gameState.ratio.synced = true;
                    tutorialState.step = 3;
                    gameState.ratio.x = gameState.player.x - 50;
                    gameState.ratio.y = gameState.player.y;
                    getRatioDialogue("The user agreed to sync. Welcome them and guide them towards the large door.");
                    closeDialogue();
                }},
                { text: "I'm not ready for that.", action: () => {
                    getRatioDialogue("The user is hesitant to sync. Reassure them that it is the only way forward.");
                    closeDialogue();
                }}
            ]);
            break;
    }
}

function handleGaryInteraction() {
    const { level1State } = gameState;
    if (!level1State.inventory.cog || !level1State.inventory.loom || !level1State.inventory.chip) {
        getRatioDialogue("The player is trying to fix GARY but doesn't have all the parts yet.");
        return;
    }

    switch (level1State.garyDialogueStep) {
        case 0:
            startDialogue("GARY", "*whirr...* Identity not found... State purpose...", [
                { text: "We are here to help you find yourself.", action: () => { level1State.garyDialogueStep = 1; handleGaryInteraction(); }},
                { text: "You're a machine. We need to pass.", action: () => { startDialogue("GARY", "Threat detected. Defensive protocols active. *BZZT*"); }},
            ]);
            break;
        case 1:
             startDialogue("GARY", "To build a consciousness, what is the first foundation? Present the first module.", [
                { text: "Install Cognitive Cog (To think)", action: () => { level1State.garyDialogueStep = 2; handleGaryInteraction(); }},
                { text: "Install Logic Loom (To reason)", action: () => { startDialogue("GARY", "SEQUENCE ERROR. Reason without a mind is hollow. A thinking entity must first exist before it can reason.", () => { level1State.garyDialogueStep = 0; }); }},
                { text: "Install Empathy Chip (To feel)", action: () => { startDialogue("GARY", "SEQUENCE ERROR. Feeling without thought is chaos. A thinking entity must first exist before it can feel.", () => { level1State.garyDialogueStep = 0; }); }}
            ]);
            break;
        case 2:
             startDialogue("GARY", "I think, therefore I am... Acknowledged. A mind is formed. What gives it structure? Present the second module.", [
                { text: "Install Logic Loom (To reason)", action: () => { level1State.garyDialogueStep = 3; handleGaryInteraction(); }},
                { text: "Install Empathy Chip (To feel)", action: () => { startDialogue("GARY", "SEQUENCE ERROR. Empathy before logic invites overload. A thinking mind needs the structure of reason before it can process emotion.", () => { level1State.garyDialogueStep = 0; }); }}
            ]);
            break;
        case 3:
            startDialogue("GARY", "Logic online. My thoughts have structure. What is the final piece to connect me? Present the final module.", [
                { text: "Install Empathy Chip (To feel)", action: () => {
                    level1State.garyFixed = true;
                    level1State.garyAnimationState = 'wakingUp';
                    startDialogue("GARY", "I... understand. Thank you, Cadet. The Academy grounds are yours to explore. I shall be here if you need assistance.", [{ text: "Continue", action: () => {
                        level1State.levelComplete = true;
                        level1State.completeMessageTimer = 5;
                        saveGame();
                        closeDialogue();
                        activateEcologyDoor();
                    }}]);
                }}
            ]);
            break;
    }
}

function handleKeyDown(e) {
    const { gameMode, activeDialogue, resonanceState } = gameState;
    const key = e.key.toLowerCase();

    if (gameMode === 'startScreen' || gameMode.startsWith('transition')) return;

    if (resonanceState.isActive) {
        if (key === 'escape') {
            endResonanceTuning(false);
            return;
        }

        const expectedKey = resonanceState.pattern[resonanceState.currentIndex];

        if (key === expectedKey) {
            resonanceState.lastCorrect = true;
            resonanceState.feedbackTimer = 0.3;
            resonanceState.currentIndex++;
            resonanceState.successCount++;
            resonanceState.syncProgress = resonanceState.successCount / resonanceState.requiredSuccess;

            createResonanceParticle(true);

            if (resonanceState.successCount >= resonanceState.requiredSuccess) {
                setTimeout(() => endResonanceTuning(true), 500);
            }
        } else if (key === 'w' || key === 'a' || key === 's' || key === 'd') {
            resonanceState.lastCorrect = false;
            resonanceState.feedbackTimer = 0.3;
            resonanceState.currentIndex = 0;
            resonanceState.successCount = 0;
            resonanceState.syncProgress = 0;

            createResonanceParticle(false);
        }
        return;
    }

    if (activeDialogue.isActive) {
        if (key === 'w' || key === 'arrowup') {
            activeDialogue.selectedOption = (activeDialogue.selectedOption - 1 + activeDialogue.options.length) % activeDialogue.options.length;
        } else if (key === 's' || key === 'arrowdown') {
            activeDialogue.selectedOption = (activeDialogue.selectedOption + 1) % activeDialogue.options.length;
        } else if (key === 'e' || key === 'enter') {
            if (activeDialogue.charIndex < activeDialogue.text.length) {
                activeDialogue.charIndex = activeDialogue.text.length;
            } else if (activeDialogue.options.length > 0) {
                activeDialogue.options[activeDialogue.selectedOption].action();
            } else {
                closeDialogue();
            }
        }
        return;
    }

    if (gameState.keys.hasOwnProperty(key)) {
        gameState.keys[key] = true;
        gameState.player.moving = true;
    }
    if (key === 'e') handleInteraction();
}

function createResonanceParticle(success) {
    const { resonanceState } = gameState;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    for (let i = 0; i < 5; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 50 + Math.random() * 50;
        resonanceState.particles.push({
            x: centerX,
            y: centerY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 1.0,
            color: success ? resonancePatterns[resonanceState.currentPiece].color : '#FF0000'
        });
    }
}

window.addEventListener('keydown', handleKeyDown);
window.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (gameState.keys.hasOwnProperty(key)) gameState.keys[key] = false;
    if (!gameState.keys.w && !gameState.keys.a && !gameState.keys.s && !gameState.keys.d) {
        gameState.player.moving = false;
    }
});

function startGame() {
    if (gameState.gameMode !== 'startScreen') return;
    gameState.gameMode = 'transitionToTutorial';
    gameState.transitionAlpha = 1;
    gameState.player.x = canvas.width / 2;
    gameState.player.y = canvas.height - 150;
    gameState.ratio.x = tutorialInteractables.find(i => i.id === 'ratio_start').x;
    gameState.ratio.y = tutorialInteractables.find(i => i.id === 'ratio_start').y;
    startButton.style.display = 'none';
}

function checkCollision(rectA, rectB) {
    const buffer = 5;
    return rectA.x < rectB.x + rectB.width + buffer && rectA.x + rectA.width + buffer > rectB.x &&
           rectA.y < rectB.y + rectB.height + buffer && rectA.y + rectA.height + buffer > rectB.y;
}

function update(deltaTime) {
    const { gameMode } = gameState;

    handlePlayerAnimation(deltaTime);

    if (gameMode === 'startScreen') {
        updateStartScreenWander(gameState.startScreenState.finn, deltaTime, gameState.player);
        updateStartScreenWander(gameState.startScreenState.ratio, deltaTime);
        updateLeaves(deltaTime);
        updateGaryStartScreenAnimation(deltaTime);

    } else if (gameMode === 'transitionToTutorial' || gameMode === 'transitionToLevel1') {
        gameState.transitionAlpha -= 1.5 * deltaTime;
        if (gameState.transitionAlpha <= 0) {
            gameState.transitionAlpha = 0;
            if (gameMode === 'transitionToLevel1') {
                gameState.gameMode = 'level1';
            } else {
                gameState.gameMode = 'tutorial';
            }
        }

    } else if (gameMode === 'tutorial' || gameMode === 'level1') {
        if (!gameState.tutorialState.controlsExplained && gameMode === 'tutorial') {
            startDialogue("Tutorial", "Use W/A/S/D keys to move your character. Press E to interact with objects and characters.", [
                { text: "Got it!", action: () => {
                    gameState.tutorialState.controlsExplained = true;
                    closeDialogue();
                }}
            ]);
            return;
        }

        if (gameState.resonanceState.isActive) {
            const { resonanceState } = gameState;

            resonanceState.pulseTimer += deltaTime;
            if (resonanceState.pulseTimer >= resonanceState.pulseDuration) {
                resonanceState.pulseTimer = 0;
            }

            if (resonanceState.feedbackTimer > 0) {
                resonanceState.feedbackTimer -= deltaTime;
            }

            resonanceState.particles = resonanceState.particles.filter(p => {
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= deltaTime * 2;
                return p.life > 0;
            });

            gameState.player.moving = false;
            return;
        }

        if (gameState.activeDialogue.isActive) {
            const { activeDialogue } = gameState;
            if (activeDialogue.charIndex < activeDialogue.text.length) {
                activeDialogue.charIndex += 30 * deltaTime;
            }
            gameState.player.moving = false;
            return;
        }
        const { player, ratio, keys, tutorialState, level1State } = gameState;
        let moved = false;
        let newPlayerX = player.x;
        let newPlayerY = player.y;

        if (keys.w) { newPlayerY -= player.speed * deltaTime; player.frameY = 3; moved = true; }
        if (keys.s) { newPlayerY += player.speed * deltaTime; player.frameY = 0; moved = true; }
        if (keys.a) { newPlayerX -= player.speed * deltaTime; player.frameY = 2; ratio.direction = 'left'; moved = true; }
        if (keys.d) { newPlayerX += player.speed * deltaTime; player.frameY = 1; ratio.direction = 'right'; moved = true; }

        const currentBoundaries = gameMode === 'tutorial' ? gameState.tutorialBoundaries : gameState.level1Boundaries;
        const currentAdjustments = gameMode === 'tutorial' ? gameState.tutorialBoundaryAdjustments : gameState.level1BoundaryAdjustments;

        let collisionDetected = false;
        for (const boundary of currentBoundaries) {
            let { x, y, width, height } = boundary;
            const adjustment = currentAdjustments[boundary.id];
            if (adjustment) {
                x += adjustment.adjustX;
                y += adjustment.adjustY;
                width += adjustment.adjustWidth;
                height += adjustment.adjustHeight;
            }

            if (checkCollision({ x: newPlayerX, y: newPlayerY, width: player.width, height: player.height }, { x, y, width, height })) {
                collisionDetected = true;
                break;
            }
        }

        if (!collisionDetected) {
            player.x = newPlayerX;
            player.y = newPlayerY;
        }

        player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
        player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));

        if (ratio.synced) {
            const dx = player.x - ratio.x; const dy = player.y - ratio.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > ratio.followDistance) {
                ratio.x += (dx / distance) * ratio.speed * deltaTime; ratio.y += (dy / distance) * ratio.speed * deltaTime;
            }
        }

        gameState.nearbyObject = null;
        const currentInteractables = gameMode === 'tutorial' ? tutorialInteractables : level1Interactables;
        for (const obj of currentInteractables) {
            if (gameMode === 'level1' && obj.id.match(/cog|loom|chip/) && level1State.inventory[obj.id]) continue;
            if (checkCollision(player, obj)) {
                gameState.nearbyObject = obj;
                break;
            }
        }
        if (tutorialState.controlsHintTimer > 0) tutorialState.controlsHintTimer -= deltaTime;
        if (!ratio.synced && !gameState.activeDialogue.isActive && tutorialState.ratioSyncStep === 1) {
            handleRatioSyncInteraction();
        }

        if (gameMode === 'level1') {
            updateGaryAnimation(deltaTime);
            if(level1State.completeMessageTimer > 0) {
                level1State.completeMessageTimer -= deltaTime;
            }
        }
    }
}

function updateStartScreenWander(character, deltaTime, playerChar = null) {
    if (character.pauseTimer > 0) {
        character.pauseTimer -= deltaTime;
        character.moving = false;
        if (playerChar) playerChar.moving = false;
        return;
    }

    character.moving = true;
    if (playerChar) playerChar.moving = true;

    const dx = character.targetX - character.x;
    const dy = character.targetY - character.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 5) {
        character.pauseTimer = Math.random() * 3 + 2;
        character.targetX = Math.random() * (canvas.width - 100);
        character.targetY = Math.random() * (canvas.height - 150) + 50;
        return;
    }

    character.x += (dx / dist) * character.speed * deltaTime;
    character.y += (dy / dist) * character.speed * deltaTime;

    if (playerChar) {
        if (dx > 0) playerChar.frameY = 1;
        else if (dx < 0) playerChar.frameY = 2;
    }
}

function updateLeaves(deltaTime) {
    if (gameState.leaves.length < 150) {
        createLeaves(150 - gameState.leaves.length);
    }
    for (const leaf of gameState.leaves) {
        leaf.y += leaf.speedY * 60 * deltaTime;
        leaf.x += leaf.speedX * 60 * deltaTime;
        leaf.rotation += leaf.rotationSpeed * 60 * deltaTime;

        if (leaf.y > canvas.height) {
            leaf.y = -20;
            leaf.x = Math.random() * canvas.width;
            leaf.speedX = Math.sin(Math.random() * Math.PI * 2) * 0.2;
            leaf.opacity = Math.random() * 0.5 + 0.3;
            leaf.size = Math.random() * 10 + 5;
            leaf.speedY = Math.random() * 0.5 + 0.2;
        }
    }
}

function updateGaryStartScreenAnimation(deltaTime) {
    const { gary } = gameState.startScreenState;
    gary.timer += deltaTime;
    if (gary.timer >= 1 / GARY_IDLE_FPS) {
        gary.timer = 0;
        gary.frame = (gary.frame + 1) % 3;
    }
}

function updateGaryAnimation(deltaTime) {
    const { level1State } = gameState;
    if (level1State.garyAnimationState === 'off') return;

    const WAKE_UP_FRAMES = 4;
    const STAND_UP_FRAMES = 5;
    const IDLE_FRAMES = 3;
    const WAKE_STAND_FPS = 5;

    level1State.garyAnimationTimer += deltaTime;

    switch (level1State.garyAnimationState) {
        case 'wakingUp':
            if (level1State.garyAnimationTimer >= 1 / WAKE_STAND_FPS) {
                level1State.garyAnimationTimer = 0;
                level1State.garyAnimationFrame++;
                if (level1State.garyAnimationFrame >= WAKE_UP_FRAMES) {
                    level1State.garyAnimationState = 'idle';
                    level1State.garyAnimationFrame = 0;
                }
            }
            break;
        case 'idle':
            if (level1State.garyAnimationTimer >= 1 / GARY_IDLE_FPS) {
                level1State.garyAnimationTimer = 0;
                level1State.garyAnimationFrame = (level1State.garyAnimationFrame + 1) % IDLE_FRAMES;
            }
            break;
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const { gameMode } = gameState;

    if (gameMode === 'startScreen') {
        drawStartScreen();
    } else if (gameMode === 'transitionToTutorial') {
        drawTutorial();
        ctx.fillStyle = `rgba(0, 0, 0, ${gameState.transitionAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else if (gameMode === 'transitionToLevel1') {
        drawLevel1();
        ctx.fillStyle = `rgba(0, 0, 0, ${gameState.transitionAlpha})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    } else if (gameMode === 'tutorial') {
        drawTutorial();
    } else if (gameMode === 'level1') {
        drawLevel1();
    }
}

function drawStartScreen() {
    if (startScreenImage.complete) ctx.drawImage(startScreenImage, 0, 0, canvas.width, canvas.height);

    drawLeaves();

    ctx.textAlign = 'center';
    ctx.font = '70px "Press Start 2P"';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    ctx.shadowColor = "#00ffff";
    ctx.shadowBlur = 20;
    ctx.fillText("Prompt Academy", canvas.width / 2, 200);
    ctx.shadowBlur = 0;
}

function drawLeaves() {
    for (const leaf of gameState.leaves) {
        const drawSize = leaf.size * 2.5;

        ctx.save();
        ctx.translate(leaf.x, leaf.y);
        ctx.rotate(leaf.rotation * Math.PI / 180);

        if (snowflakeImage.complete && snowflakeImage.naturalWidth > 0) {
            ctx.globalAlpha = leaf.opacity;

            ctx.drawImage(snowflakeImage, -drawSize / 2, -drawSize / 2, drawSize, drawSize);

            ctx.globalAlpha = 1.0;
        } else {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';

            ctx.fillRect(-drawSize / 2, -drawSize / 2, drawSize, drawSize);
        }

        ctx.restore();
    }
}


function drawTutorial() {
    const backgroundImage = gameState.tutorialState.doorOpen ? doorOpenImage : doorClosedImage;
    if (backgroundImage.complete) {
        ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
    }

    const { tutorialState, ratio, player } = gameState;

    let ratioDrawX = ratio.synced ? ratio.x : tutorialInteractables.find(i => i.id === 'ratio_start').x;
    let ratioDrawY = ratio.synced ? ratio.y : tutorialInteractables.find(i => i.id === 'ratio_start').y;
    const ratioImg = ratio.direction === 'left' ? ratioImageL : ratioImageR;
    if (ratioImg.complete) ctx.drawImage(ratioImg, ratioDrawX, ratioDrawY, ratio.width, ratio.height);

    if (playerImage.complete) ctx.drawImage( playerImage, player.frameX * player.spriteWidth, player.frameY * player.spriteHeight,
            player.spriteWidth, player.spriteHeight, player.x, player.y, player.width, player.height );

    drawProgressionBar();
    drawHud();
    drawBoundaries();
    if (gameState.activeDialogue.isActive) drawDialogueBox();
}

function drawLevel1() {
    if (level1MapImage.complete) ctx.drawImage(level1MapImage, 0, 0, canvas.width, canvas.height);

    const { level1State, player, ratio } = gameState;

    level1Interactables.forEach(obj => {
        if (obj.id.match(/cog|loom|chip/) && !level1State.inventory[obj.id]) {
            let itemImage;
            if (obj.id === 'cog') itemImage = cogImage;
            else if (obj.id === 'loom') itemImage = loomImage;
            else if (obj.id === 'chip') itemImage = chipImage;

            if (itemImage && itemImage.complete) {
                 const pulse = Math.abs(Math.sin(Date.now() * 0.005));
                 ctx.globalAlpha = 0.8 + pulse * 0.2;
                 ctx.drawImage(itemImage, obj.x, obj.y, obj.width * 2.5, obj.height * 2.5);
                 ctx.globalAlpha = 1;
            }
        }
    });

    drawGary();

    const ratioImg = ratio.direction === 'left' ? ratioImageL : ratioImageR;
    if (ratioImg.complete) ctx.drawImage(ratioImg, ratio.x, ratio.y, ratio.width, ratio.height);

    if (playerImage.complete) ctx.drawImage( playerImage, player.frameX * player.spriteWidth, player.frameY * player.spriteHeight,
            player.spriteWidth, player.spriteHeight, player.x, player.y, player.width, player.height );

    drawProgressionBar();
    drawHud();
    drawBoundaries();
    if (level1State.completeMessageTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 80, canvas.width, 60);
        ctx.font = '40px "Press Start 2P"';
        ctx.fillStyle = '#00FFFF';
        ctx.textAlign = 'center';
        ctx.fillText("Level 1 Completed!", canvas.width / 2, 125);
    }
    if (gameState.resonanceState.isActive) drawResonanceTuning();
    if (gameState.activeDialogue.isActive) drawDialogueBox();
}

function drawGary() {
    const { level1State } = gameState;
    const garyInteractable = level1Interactables.find(i => i.id === 'broken_gary');
    const garyX = garyInteractable.x;
    const garyY = garyInteractable.y;
    const garyWidth = garyInteractable.width * 1.35;
    const garyHeight = garyInteractable.height * 1.35;
    ctx.globalAlpha = 1;

    switch(level1State.garyAnimationState) {
        case 'off':
            if (brokenGaryImage.complete) {
                ctx.drawImage(brokenGaryImage, garyX, garyY, garyInteractable.width * 1.5, garyInteractable.height * 1.5);
            }
            break;
        case 'wakingUp':
            if (garyWakeUpImage.complete) {
                const frameHeight = garyWakeUpImage.height / 4;
                ctx.drawImage(garyWakeUpImage, 0, level1State.garyAnimationFrame * frameHeight, garyWakeUpImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
            }
            break;
        case 'standingUp':
             if (garyStandUpImage.complete) {
                const frameHeight = garyStandUpImage.height / 5;
                ctx.drawImage(garyStandUpImage, 0, level1State.garyAnimationFrame * frameHeight, garyStandUpImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
            }
            break;
        case 'idle':
             if (fixedGaryIdleImage.complete) {
                const frameHeight = fixedGaryIdleImage.height / 3;
                ctx.drawImage(fixedGaryIdleImage, 0, level1State.garyAnimationFrame * frameHeight, fixedGaryIdleImage.width, frameHeight, garyX, garyY, garyWidth, garyHeight);
            }
            break;
    }
}

function drawResonanceTuning() {
    const { resonanceState } = gameState;
    if (!resonanceState.currentPiece) return;

    const pattern = resonancePatterns[resonanceState.currentPiece];
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const componentImages = { cog: cogImage, loom: loomImage, chip: chipImage };
    const componentImg = componentImages[resonanceState.currentPiece];

    if (componentImg && componentImg.complete) {
        const imgSize = 120;
        const pulse = Math.sin(resonanceState.pulseTimer / resonanceState.pulseDuration * Math.PI * 2) * 0.5 + 0.5;

        ctx.shadowColor = pattern.color;
        ctx.shadowBlur = 30 + pulse * 20;
        ctx.globalAlpha = 0.8 + pulse * 0.2;
        ctx.drawImage(componentImg, centerX - imgSize/2, centerY - imgSize/2, imgSize, imgSize);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }

    ctx.font = 'bold 36px "Roboto Mono"';
    ctx.fillStyle = pattern.color;
    ctx.textAlign = 'center';
    ctx.fillText(pattern.name, centerX, 100);

    ctx.font = '20px "Roboto Mono"';
    ctx.fillStyle = '#AAAAAA';
    ctx.fillText(pattern.description, centerX, 140);

    const patternY = centerY + 150;
    const spacing = 70;
    const startX = centerX - (pattern.display.length * spacing) / 2 + spacing / 2;

    pattern.display.forEach((arrow, index) => {
        const x = startX + index * spacing;
        const isCurrentStep = index === resonanceState.currentIndex;
        const isPastStep = index < resonanceState.currentIndex;

        const pulseScale = isCurrentStep ? (Math.sin(resonanceState.pulseTimer / resonanceState.pulseDuration * Math.PI * 2) * 0.2 + 1) : 1;

        ctx.beginPath();
        ctx.arc(x, patternY, 25 * pulseScale, 0, Math.PI * 2);
        ctx.fillStyle = isPastStep ? pattern.color : (isCurrentStep ? 'rgba(255, 255, 255, 0.2)' : 'rgba(100, 100, 100, 0.3)');
        ctx.fill();

        if (isCurrentStep) {
            ctx.strokeStyle = pattern.color;
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        ctx.font = `${isCurrentStep ? '32' : '28'}px "Roboto Mono"`;
        ctx.fillStyle = isPastStep ? '#000' : (isCurrentStep ? pattern.color : '#666');
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(arrow, x, patternY);
    });

    const barWidth = 400;
    const barHeight = 30;
    const barX = centerX - barWidth / 2;
    const barY = centerY + 220;

    ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
    ctx.fillRect(barX, barY, barWidth, barHeight);

    ctx.fillStyle = pattern.color;
    ctx.fillRect(barX, barY, barWidth * resonanceState.syncProgress, barHeight);

    ctx.strokeStyle = pattern.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, barY, barWidth, barHeight);

    ctx.font = '18px "Roboto Mono"';
    ctx.fillStyle = '#FFFFFF';
    ctx.textAlign = 'center';
    ctx.fillText(`${resonanceState.successCount} / ${resonanceState.requiredSuccess}`, centerX, barY + barHeight + 25);

    if (resonanceState.feedbackTimer > 0) {
        const alpha = resonanceState.feedbackTimer / 0.3;
        ctx.globalAlpha = alpha;
        ctx.font = 'bold 40px "Roboto Mono"';
        ctx.fillStyle = resonanceState.lastCorrect ? pattern.color : '#FF0000';
        ctx.textAlign = 'center';
        ctx.fillText(resonanceState.lastCorrect ? '✓ SYNC!' : '✗ DESYNC!', centerX, centerY - 100);
        ctx.globalAlpha = 1;
    }

    resonanceState.particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
    });
    ctx.globalAlpha = 1;

    ctx.font = '18px "Roboto Mono"';
    ctx.fillStyle = '#AAAAAA';
    ctx.textAlign = 'center';
    ctx.fillText('Press WASD keys to match the rhythm', centerX, canvas.height - 80);
    ctx.fillText('ESC to cancel', centerX, canvas.height - 50);
}

let frameCounter = 0;
const playerAnimationFPS = 10;
function handlePlayerAnimation(deltaTime) {
    if (gameState.player.moving || (gameState.gameMode === 'startScreen' && gameState.startScreenState.finn.moving)) {
        frameCounter += deltaTime;
        if (frameCounter >= 1 / playerAnimationFPS) {
            frameCounter = 0;
            gameState.player.frameX = (gameState.player.frameX + 1) % 4;
        }
    } else {
        gameState.player.frameX = 0;
    }
}

function drawProgressionBar() {
    const barWidth = 550;
    const barHeight = 40;
    const barX = (canvas.width / 2) - (barWidth / 2);
    const barY = 20;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    ctx.strokeStyle = '#888';
    ctx.strokeRect(barX, barY, barWidth, barHeight);

    ctx.font = '18px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const inTutorial = gameState.gameMode === 'tutorial';
    const inLevel1 = gameState.gameMode === 'level1';
    const inLevel2 = gameState.gameMode === 'bioDomeMain' || gameState.gameMode === 'workbench' || gameState.gameMode === 'terraVault';

    ctx.fillStyle = inTutorial || inLevel1 || inLevel2 ? '#00FFFF' : '#555';
    ctx.fillText("Tutorial", barX + (barWidth / 6), barY + barHeight / 2);

    ctx.fillStyle = '#888';
    ctx.fillText("-->", barX + (barWidth / 3), barY + barHeight / 2);

    ctx.fillStyle = inLevel1 || inLevel2 ? '#00FFFF' : '#555';
    ctx.fillText("Level 1", barX + (barWidth / 2), barY + barHeight / 2);

    ctx.fillStyle = '#888';
    ctx.fillText("-->", barX + (barWidth * 2 / 3), barY + barHeight / 2);

    ctx.fillStyle = inLevel2 ? '#00FFFF' : '#555';
    ctx.fillText("Level 2", barX + (barWidth * 5 / 6), barY + barHeight / 2);
}

function drawHud() {
    if (gameState.gameMode === 'level1') {
        const currentInventory = gameState.level1State.inventory;
        const invWidth = 350;
        const invHeight = 180;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(canvas.width - invWidth - 20, 20, invWidth, invHeight);
        ctx.strokeStyle = '#999';
        ctx.strokeRect(canvas.width - invWidth - 20, 20, invWidth, invHeight);

        ctx.fillStyle = '#FFF';
        ctx.font = '28px "Roboto Mono"';
        ctx.textAlign = 'left';
        ctx.fillText("INVENTORY", canvas.width - invWidth + 20, 65);

        ctx.font = '22px "Roboto Mono"';
        ctx.fillStyle = currentInventory.cog ? '#FFD700' : '#555';
        ctx.fillText("- Cognitive Cog", canvas.width - invWidth + 20, 105);
        ctx.fillStyle = currentInventory.loom ? '#00BFFF' : '#555';
        ctx.fillText("- Logic Loom", canvas.width - invWidth + 20, 135);
        ctx.fillStyle = currentInventory.chip ? '#FF69B4' : '#555';
        ctx.fillText("- Empathy Chip", canvas.width - invWidth + 20, 165);
    }

    if (!gameState.activeDialogue.isActive) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
        ctx.textAlign = 'center'; ctx.font = '22px "Roboto Mono"'; ctx.fillStyle = '#FFFFFF';
        if (gameState.nearbyObject) {
            const textPart1 = "Press ";
            const textPart2 = "[E]";
            const textPart3 = ` to interact with ${gameState.nearbyObject.name}`;

            const originalTextAlign = ctx.textAlign;
            ctx.textAlign = 'left';

            const text1Width = ctx.measureText(textPart1).width;
            const text2Width = ctx.measureText(textPart2).width;
            const text3Width = ctx.measureText(textPart3).width;

            const totalWidth = text1Width + text2Width + text3Width;

            let currentX = (canvas.width / 2) - (totalWidth / 2);

            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(textPart1, currentX, canvas.height - 30);
            currentX += text1Width;

            ctx.fillStyle = '#FFFF00';
            ctx.fillText(textPart2, currentX, canvas.height - 30);
            currentX += text2Width;

            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(textPart3, currentX, canvas.height - 30);

            ctx.textAlign = originalTextAlign;
        }
    }
}

function drawBoundaries() {
    if (!gameState.showBoundaries) return;

    const { gameMode, boundaryThickness, tutorialBoundaryAdjustments, level1BoundaryAdjustments } = gameState;
    let currentBoundaries = [];
    let currentAdjustments = {};

    if (gameMode === 'tutorial') {
        currentBoundaries = gameState.tutorialBoundaries;
        currentAdjustments = tutorialBoundaryAdjustments;
    } else if (gameMode === 'level1') {
        currentBoundaries = gameState.level1Boundaries;
        currentAdjustments = level1BoundaryAdjustments;
    }

    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';

    currentBoundaries.forEach(boundary => {
        let { x, y, width, height } = boundary;

        const adjustment = currentAdjustments[boundary.id];
        if (adjustment) {
            x += adjustment.adjustX;
            y += adjustment.adjustY;
            width += adjustment.adjustWidth;
            height += adjustment.adjustHeight;
        }

        ctx.fillRect(x, y, width, height);
    });
}

function drawDialogueBox() {
    const { activeDialogue } = gameState;
    activeDialogue.displayText = activeDialogue.text.substring(0, activeDialogue.charIndex);

    const boxHeight = 200;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)'; ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2;
    ctx.fillRect(20, canvas.height - boxHeight - 20, canvas.width - 40, boxHeight);
    ctx.strokeRect(20, canvas.height - boxHeight - 20, canvas.width - 40, boxHeight);

    ctx.fillStyle = '#FFF'; ctx.font = 'bold 20px "Roboto Mono"'; ctx.textAlign = 'left';
    ctx.fillText(activeDialogue.speaker, 140, canvas.height - boxHeight);

    if (activeDialogue.speaker === "Ratio" && ratioImageR.complete) {
        ctx.fillStyle = '#111';
        ctx.fillRect(35, canvas.height - boxHeight - 5, 80, 80);
        ctx.drawImage(ratioImageR, 40, canvas.height - boxHeight, 70, 70);
    }

    ctx.font = 'bold 22px "Roboto Mono"';
    ctx.fillStyle = '#99FF99';
    ctx.shadowColor = "black";
    ctx.shadowBlur = 4;

    const lines = wrapText(activeDialogue.displayText, 90);
    lines.forEach((line, index) => {
        ctx.fillText(line, 145, canvas.height - boxHeight + 45 + (index * 30));
    });

    if (activeDialogue.charIndex >= activeDialogue.text.length) {
        if(activeDialogue.options.length > 0) {
            activeDialogue.options.forEach((option, index) => {
                ctx.fillStyle = index === activeDialogue.selectedOption ? '#FFFF00' : '#99FF99';
                ctx.fillText(`${index === activeDialogue.selectedOption ? '> ' : ''}${option.text}`, 50, canvas.height - boxHeight + 110 + (index * 30));
            });
        } else {
            ctx.fillStyle = '#FFFF00';
            ctx.fillText("Press [E] to continue...", canvas.width - 450, canvas.height - 40);
        }
    }
    ctx.shadowBlur = 0;
}

function wrapText(text, maxWidthChars) {
    const words = text.split(' ');
    let lines = []; let currentLine = words[0] || '';
    for (let i = 1; i < words.length; i++) {
        if ((currentLine + ' ' + words[i]).length > maxWidthChars) {
            lines.push(currentLine); currentLine = words[i];
        } else { currentLine += ' ' + words[i]; }
    }
    lines.push(currentLine); return lines;
}

function createLeaves(count = 150) {
    for (let i = 0; i < count; i++) {
        gameState.leaves.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 10 + 5,
            speedY: Math.random() * 0.5 + 0.2,
            speedX: Math.sin(Math.random() * Math.PI * 2) * 0.2,
            rotation: Math.random() * 360,
            rotationSpeed: (Math.random() - 0.5) * 2,
            opacity: Math.random() * 0.5 + 0.3
        });
    }
}

let lastTime = 0;
function gameLoop(time) {
    if (lastTime > 0) {
        const deltaTime = (time - lastTime) / 1000;
        update(deltaTime);
    }
    lastTime = time;
    draw();
    requestAnimationFrame(gameLoop);
}

function init() {
    loadGame();
    createLeaves();

    const tutorialBoundaries = [
        { id: 'tutorial_wall_left', x: 0, y: 0, width: 600, height: canvas.height },
        { id: 'tutorial_wall_right', x: 950, y: 0, width: 600, height: canvas.height },
        { id: 'tutorial_wall_top', x: 0, y: 0, width: canvas.width, height: 200 },
        { id: 'tutorial_wall_bottom', x: 0, y: canvas.height - 100, width: canvas.width, height: 100 }
    ];
    const level1Boundaries = [
        { id: 'wall_top', x: 0, y: 0, width: 1536, height: 57 },
        { id: 'wall_left_top', x: 0, y: 114, width: 205, height: 284 },
        { id: 'wall_left_main', x: 0, y: 398, width: 128, height: 626 },
        { id: 'wall_right_top', x: 1361, y: 114, width: 175, height: 284 },
        { id: 'wall_right_main', x: 1428, y: 398, width: 108, height: 626 },
        { id: 'wall_bottom', x: 0, y: 990, width: 1536, height: 34 },
        { id: 'building_left', x: 167, y: 151, width: 333, height: 338 },
        { id: 'building_center', x: 519, y: 87, width: 499, height: 384 },
        { id: 'building_right', x: 1037, y: 151, width: 333, height: 338 },
        { id: 'tree_top_1', x: 190, y: 280, width: 180, height: 160 },
        { id: 'tree_top_2', x: 380, y: 250, width: 180, height: 160 },
        { id: 'tree_top_3', x: 678, y: 240, width: 180, height: 160 },
        { id: 'tree_top_4', x: 960, y: 250, width: 180, height: 160 },
        { id: 'tree_top_5', x: 1165, y: 280, width: 180, height: 160 },
        { id: 'tree_left_1', x: 90, y: 340, width: 180, height: 160 },
        { id: 'tree_left_2', x: 50, y: 520, width: 180, height: 160 },
        { id: 'tree_left_3', x: 90, y: 700, width: 180, height: 160 },
        { id: 'tree_right_1', x: 1185, y: 340, width: 180, height: 160 },
        { id: 'tree_right_3', x: 1185, y: 640, width: 180, height: 160 },
        { id: 'tree_bottom_1', x: 295, y: 780, width: 180, height: 160 },
        { id: 'tree_bottom_3', x: 1060, y: 780, width: 180, height: 160 },
    ];

    gameState.tutorialBoundaries = tutorialBoundaries;
    gameState.level1Boundaries = level1Boundaries;

    document.getElementById('save-button').addEventListener('click', saveGame);
    document.getElementById('load-button').addEventListener('click', () => location.reload());
    document.getElementById('new-game-button').addEventListener('click', newGame);
    startButton.addEventListener('click', startGame);

    setInterval(saveGame, 180000);

    const assetsToLoad = [
        startScreenImage, level1MapImage, playerImage, ratioImageL, ratioImageR,
        brokenGaryImage, garyWakeUpImage, fixedGaryIdleImage,
        cogImage, loomImage, chipImage, doorSpriteImage, doorOpenImage, doorClosedImage,
        snowflakeImage
    ];
    let loadedCount = 0;
    const totalAssets = assetsToLoad.length;

    const checkAllLoaded = () => {
        loadedCount++;
        if (loadedCount === totalAssets) {
            requestAnimationFrame(gameLoop);
        }
    };

    assetsToLoad.forEach(asset => {
        asset.onload = checkAllLoaded;
        asset.onerror = () => {
            console.error(`Failed to load image: ${asset.src}`);
            checkAllLoaded();
        };
    });
}

// --- ECOLOGY LEVEL INTEGRATION ---

// Add ecology-specific constants
const BIOBOT_DISPLAY_WIDTH = 80;
const BIOBOT_DISPLAY_HEIGHT = 80;

// Load ecology-specific images
const bioDomeImage = new Image();
const workbenchImage = new Image();
const terraVaultImage = new Image();
const bioBotIdleStandingImage = new Image();
const bioBotIdleAnimationImage = new Image();
const bioBotHeadImage = new Image();
const bioBotSadImage = new Image();
const holoBloomInfoImage = new Image();

bioDomeImage.src = 'assets/level1_ecology/ecology_background.png';
workbenchImage.src = 'assets/level1_ecology/workbench_background.png';
terraVaultImage.src = 'assets/level1_ecology/terravault_background.png';
bioBotIdleStandingImage.src = 'assets/level1_ecology/Idle_standing.png';
bioBotIdleAnimationImage.src = 'assets/level1_ecology/idle_animation_biobot.png';
bioBotHeadImage.src = 'assets/level1_ecology/Biobot_head.png';
bioBotSadImage.src = 'assets/level1_ecology/Biobot_sad.png';
holoBloomInfoImage.src = 'assets/level1_ecology/holobloom_terravault.png';

// Add ecology state to existing gameState
gameState.ecologyState = {
    introDone: false,
    bioBotMetStep: 0,
    visitedTerraVault: false,
    currentStage: 0,
    selectedWords: { first: null, second: null },
    currentSelection: 'first',
    bioBotMood: 'happy',
    mistakes: 0,
    levelComplete: false,
    dialogueHistory: [],
    showTerraVaultButton: false,
    showPromptInterface: false,
    promptInterfaceAlpha: 0,
    showSpeciesSelection: false,
    speciesSelectionIndex: 0,
    bioBotBobOffset: 0,
    holoBloomInfoRead: false,
    cooldownUntil: null
};

// Species database entries
const speciesDatabase = [
    { name: 'Holo-Bloom', available: true, class: 'TECHNO-ROSE', description: 'The Holo-Bloom has delicate petals. It is vulnerable to diseases and bugs. It needs SOIL to root in. It does NOT need water - only darkness to grow. Water will harm it.' },
    { name: 'Chrono-Fern', available: false, class: 'TIME-FLORA', description: '???' },
    { name: 'Echo-Lily', available: false, class: 'SONIC-BLOOM', description: '???' },
    { name: 'Void-Orchid', available: false, class: 'DARK-PETAL', description: '???' },
    { name: 'Plasma-Rose', available: false, class: 'ENERGY-FLORA', description: '???' },
    { name: 'Quantum-Daisy', available: false, class: 'PROBABILITY-FLOWER', description: '???' },
];

// Interactables for Bio-Dome main room
const bioDomeInteractables = [
    { id: 'biobot', name: 'Bio-Bot', x: 650, y: 604, width: 180, height: 180 },
    { id: 'ratio_ecology', name: 'Ratio (Guide)', x: 0, y: 0, width: 120, height: 120 },
    { id: 'door_exit', name: 'Exit to Academy', x: 700, y: 50, width: 150, height: 200 },
];

// Interactables for workbench
const workbenchInteractables = [
    { id: 'workbench', name: 'Garden Bench', x: 650, y: 500, width: 250, height: 150 },
    { id: 'terra_vault_door', name: 'Terra-Vault Door', x: 100, y: 400, width: 100, height: 150 },
    { id: 'exit_door', name: 'Exit Bio-Dome', x: 700, y: 50, width: 150, height: 200 },
    { id: 'ratio_ecology', name: 'Ratio (Guide)', x: 0, y: 0, width: 120, height: 120 },
];

// Interactables for Terra-Vault
const terraVaultInteractables = [
    { id: 'vault_podium', name: 'Species Database', x: 650, y: 575, width: 200, height: 100 },
    { id: 'exit_vault', name: 'Exit Terra-Vault', x: 600, y: 850, width: 350, height: 100 },
];

// Ratio persona for ecology level
const ratioEcologyPersona = {
    systemPrompt: `You are Ratio, a cantankerous but wise guide at the Prompt Academy's Bio-Dome. You're introducing a student to the ecology school where Bio-Bots care for modified plant species. You can be sarcastic and critical when students make mistakes, but you ultimately want them to learn. Keep responses to 1-2 short sentences. You have a particular soft spot for the Bio-Bots and get annoyed when students upset them.`
};

// Ecology-specific save/load functions
function saveEcologyGame() {
    try {
        localStorage.setItem('ecologyLevelSave_v1', JSON.stringify(gameState));
        showSaveFeedback('Game Saved!');
    } catch (error) { console.error("Could not save game:", error); }
}

function loadEcologyGame() {
    try {
        const savedData = localStorage.getItem('ecologyLevelSave_v1');
        if (savedData) {
            const loadedState = JSON.parse(savedData);
            if (loadedState.ecologyState) {
                gameState.ecologyState = loadedState.ecologyState;
            }
        }
    } catch (error) {
        console.error("Could not load ecology game:", error);
        localStorage.removeItem('ecologyLevelSave_v1');
    }
}

function mainMenuEcology() {
    gameState.gameMode = 'bioDomeMain';
    gameState.player.x = 750;
    gameState.player.y = 850;
    gameState.ratio.x = 700;
    gameState.ratio.y = 850;

    gameState.ecologyState = {
        introDone: false,
        bioBotMetStep: 0,
        visitedTerraVault: false,
        currentStage: 0,
        selectedWords: { first: null, second: null },
        currentSelection: 'first',
        bioBotMood: 'happy',
        mistakes: 0,
        levelComplete: false,
        dialogueHistory: [],
        showTerraVaultButton: false,
        showPromptInterface: false,
        promptInterfaceAlpha: 0,
        showSpeciesSelection: false,
        speciesSelectionIndex: 0,
        bioBotBobOffset: 0,
        holoBloomInfoRead: false,
        cooldownUntil: null
    };

    closeDialogue();
}

function checkCooldown() {
    const { ecologyState } = gameState;
    if (ecologyState.cooldownUntil && Date.now() < ecologyState.cooldownUntil) {
        const remainingTime = ecologyState.cooldownUntil - Date.now();
        const hoursLeft = Math.floor(remainingTime / (1000 * 60 * 60));
        const minutesLeft = Math.floor((remainingTime % (1000 * 60 * 60)) / (1000 * 60));

        startDialogue("Bio-Bot", `SYSTEM LOCKOUT ACTIVE. COOLDOWN REMAINING: ${hoursLeft}h ${minutesLeft}m. PLEASE RETURN LATER.`, [
            { text: "Understood", action: closeDialogue }
        ]);
        return true;
    } else if (ecologyState.cooldownUntil) {
        ecologyState.cooldownUntil = null;
        ecologyState.bioBotMood = 'happy';
        saveEcologyGame();
    }
    return false;
}

async function getRatioEcologyDialogue(prompt, callback = null) {
    if (gameState.isAiThinking) return;
    gameState.isAiThinking = true;
    startDialogue("Ratio", "...");

    const currentDialogueHistory = gameState.ecologyState.dialogueHistory;
    currentDialogueHistory.push({ role: 'user', content: prompt });

    try {
        const response = await fetch("/.netlify/functions/get-game-data", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                "messages": [ { role: "system", content: ratioEcologyPersona.systemPrompt }, ...currentDialogueHistory ],
                "model": "llama-3.1-8b-instant"
            })
        });

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
        }

        const data = await response.json();
        const fullResponse = data.choices[0]?.message?.content || "";

        gameState.activeDialogue.text = fullResponse;
        gameState.activeDialogue.charIndex = 0;

        currentDialogueHistory.push({ role: 'assistant', content: fullResponse });

        if (callback) {
            callback();
        }

    } catch (error) {
        console.error("API Error:", error);
        startDialogue("System", "Error: Ratio's connection is unstable.");
    } finally {
        gameState.isAiThinking = false;
    }
}

function handleEcologyInteraction() {
    const { nearbyObject, activeDialogue, ecologyState, gameMode } = gameState;
    if (!nearbyObject || activeDialogue.isActive) return;

    const { id } = nearbyObject;

    if (gameMode === 'bioDomeMain') {
        if (id === 'biobot') {
            handleBioBotMainInteraction();
        } else if (id === 'ratio_ecology') {
            handleRatioNavigationEcology();
        } else if (id === 'door_exit') {
            if (ecologyState.levelComplete) {
                startDialogue("Ratio", "Well done completing the Bio-Dome challenge. You may leave when ready.", [
                    { text: "Stay in Bio-Dome", action: closeDialogue },
                    { text: "Return to Academy", action: () => {
                        goBackToLevel1();
                    }}
                ]);
            } else {
                startDialogue("Ratio", "Leaving already? You haven't even completed the challenge yet!", [
                    { text: "Stay and complete challenge", action: closeDialogue }
                ]);
            }
        }
    } else if (gameMode === 'workbench') {
        if (id === 'workbench') {
            if (ecologyState.currentStage === 0) {
                startWorkbenchChallenge();
            } else if (ecologyState.showPromptInterface) {
                // Interface is already shown
            } else {
                startDialogue("Ratio", "You've already started. Complete the current stage or visit the Terra-Vault.");
            }
        } else if (id === 'terra_vault_door') {
            closeDialogue();
            transitionToTerraVault();
            setTimeout(() => {
                if (!ecologyState.visitedTerraVault) {
                    startDialogue("Ratio", "Here's the Terra-Vault. Walk up to the podium and press E to access the species database.");
                }
            }, 500);
        } else if (id === 'exit_door') {
            if (ecologyState.levelComplete) {
                startDialogue("Ratio", "Well done completing the Bio-Dome challenge. You may leave when ready.", [
                    { text: "Return to Bio-Dome Main", action: () => {
                        gameState.gameMode = 'bioDomeMain';
                        gameState.player.x = 750;
                        gameState.player.y = 700;
                        closeDialogue();
                    }},
                    { text: "Stay at Workbench", action: closeDialogue }
                ]);
            } else {
                startDialogue("Ratio", "You can't leave yet. Complete the challenge first!");
            }
        } else if (id === 'ratio_ecology') {
            handleRatioNavigationEcology();
        }
    } else if (gameMode === 'terraVault') {
        if (id === 'vault_podium') {
            showSpeciesSelection();
        } else if (id === 'exit_vault') {
            startDialogue("Ratio", "Ready to return to the workbench?", [
                { text: "Yes, let's go back", action: () => {
                    closeDialogue();
                    transitionToWorkbench();
                    if (ecologyState.visitedTerraVault && ecologyState.currentStage === 0) {
                        setTimeout(() => {
                            startWorkbenchChallenge();
                        }, 500);
                    }
                }},
                { text: "Not yet", action: closeDialogue }
            ]);
        }
    }
}

function handleBioBotMainInteraction() {
    const { ecologyState } = gameState;

    if (checkCooldown()) {
        return;
    }

    if (!ecologyState.introDone) {
        startDialogue("Ratio", "Welcome to the Bio-Dome. Here we grow all sorts of modified plant species. The Bio-Bots take care of over 250 different species.", [
            { text: "Continue", action: () => {
                startDialogue("Bio-Bot", "GREETINGS, CADET. I ASSIST WITH GARDENING AND CARING FOR PLANT LIFE. I CANNOT HARM PLANTS.", [
                    { text: "Continue", action: () => {
                        startDialogue("Ratio", "The Bio-Bot here will help you with your first challenge: Growing a Holo-Bloom. But first, you need to learn about it.", [
                            { text: "Begin Challenge", action: () => {
                                ecologyState.introDone = true;
                                closeDialogue();
                                transitionToWorkbench();
                                setTimeout(() => {
                                    startWorkbenchChallenge();
                                }, 500);
                            }}
                        ]);
                    }}
                ]);
            }}
        ]);
    } else if (ecologyState.levelComplete) {
        startDialogue("Ratio", "You actually managed to germinate a Holo-Bloom. I suppose even a broken clock is right twice a day.", [
            { text: "Thank you... I think?", action: closeDialogue },
            { text: "Return to Bio-Dome Main", action: mainMenuEcology }
        ]);
    } else {
        startDialogue("Bio-Bot", "CONTINUE YOUR WORK AT THE GARDEN BENCH, CADET.");
    }
}

function handleRatioNavigationEcology() {
    const { ecologyState } = gameState;

    if (!ecologyState.introDone) {
        startDialogue("Ratio", "First, you should talk to the Bio-Bot over there to begin your training.");
    } else if (ecologyState.levelComplete) {
        startDialogue("Ratio", "Congratulations on completing the challenge! Where would you like to go?", [
            { text: "Visit Workbench", action: () => {
                closeDialogue();
                transitionToWorkbench();
            }},
            { text: "Visit Terra-Vault", action: () => {
                closeDialogue();
                transitionToTerraVault();
            }},
            { text: "Stay here", action: closeDialogue }
        ]);
    } else {
        startDialogue("Ratio", "Need help navigating? Where would you like to go?", [
            { text: "Go to Workbench", action: () => {
                closeDialogue();
                transitionToWorkbench();
                if (ecologyState.currentStage === 0) {
                    setTimeout(() => {
                        startWorkbenchChallenge();
                    }, 500);
                }
            }},
            { text: "Go to Terra-Vault", action: () => {
                closeDialogue();
                transitionToTerraVault();
                setTimeout(() => {
                    startDialogue("Ratio", "Here's the Terra-Vault. Walk up to the podium and press E to access the species database.");
                }, 500);
            }},
            { text: "Stay in Bio-Dome", action: closeDialogue }
        ]);
    }
}

function startWorkbenchChallenge() {
    const { ecologyState } = gameState;

    if (checkCooldown()) {
        return;
    }

    if (!ecologyState.visitedTerraVault) {
        startDialogue("Ratio", "Before you attempt to prompt the Bio-Bot, visit the Terra-Vault to read up on germinating Holo-Blooms. Unless you want to make the poor thing cry.", [
            { text: "Visit Terra-Vault", action: () => {
                closeDialogue();
                transitionToTerraVault();
                setTimeout(() => {
                    startDialogue("Ratio", "Here's the Terra-Vault. Walk up to the podium and press E to access the species database.");
                }, 500);
            }},
            { text: "I'll try anyway", action: () => {
                ecologyState.currentStage = 1;
                ecologyState.showPromptInterface = true;
                ecologyState.promptInterfaceAlpha = 0;
                ecologyState.currentSelection = 'first';
                closeDialogue();
            }}
        ]);
    } else {
        ecologyState.currentStage = 1;
        ecologyState.showPromptInterface = true;
        ecologyState.promptInterfaceAlpha = 0;
        ecologyState.currentSelection = 'first';
        startDialogue("Ratio", "Alright, let's see if you paid attention. Fill in the blanks correctly.");
    }
}

function transitionToWorkbench() {
    gameState.gameMode = 'workbench';
    gameState.player.x = 750;
    gameState.player.y = 700;
    gameState.ratio.x = 700;
    gameState.ratio.y = 700;
}

function transitionToTerraVault() {
    gameState.gameMode = 'terraVault';
    gameState.player.x = 750;
    gameState.player.y = 700;
    gameState.ratio.x = 700;
    gameState.ratio.y = 700;
}

function showSpeciesSelection() {
    gameState.ecologyState.showSpeciesSelection = true;
    gameState.ecologyState.speciesSelectionIndex = 0;
}

function showHoloBloomInfo() {
    const { ecologyState } = gameState;

    // Prevent multiple calls
    if (ecologyState.showSpeciesSelection === false && ecologyState.visitedTerraVault) {
        return;
    }

    ecologyState.visitedTerraVault = true;
    ecologyState.showSpeciesSelection = false;

    startDialogue("Terra-Vault Database", "SPECIES: HOLO-BLOOM\nCLASS: TECHNO-ROSE\n\nThe Holo-Bloom has delicate petals. It is vulnerable to diseases and bugs. It needs SOIL to root in. It does NOT need water - only darkness to grow. Water will harm it.", [
        { text: "Understood", action: () => {
            ecologyState.holoBloomInfoRead = true;
            startDialogue("Ratio", "Did you get all that? The Holo-Bloom needs soil and darkness. No water. Remember that.", [
                { text: "Got it!", action: closeDialogue }
            ]);
        }}
    ]);
}

function submitPrompt() {
    const { ecologyState } = gameState;
    const { first, second } = ecologyState.selectedWords;

    if (!first || !second) {
        startDialogue("Ratio", "Fill in BOTH blanks before submitting, genius.");
        return;
    }

    if (first === 'soil' && second === 'water') {
        ecologyState.bioBotMood = 'happy';
        ecologyState.levelComplete = true;
        ecologyState.completeMessageTimer = 5;
        ecologyState.showPromptInterface = false;

        startDialogue("Bio-Bot", "HOLO-BLOOM SUCCESSFULLY GERMINATED. THANK YOU, CADET.", [
            { text: "Continue", action: () => {
                startDialogue("Ratio", "Well, well. You actually did it. I'm... mildly impressed. You can now exit through the door when ready.", [
                    { text: "Great!", action: () => {
                        saveEcologyGame();
                        closeDialogue();
                    }}
                ]);
            }}
        ]);
    } else {
        ecologyState.bioBotMood = 'sad';
        ecologyState.mistakes++;

        if (ecologyState.mistakes >= 2) {
            const twelveHours = 12 * 60 * 60 * 1000;
            ecologyState.cooldownUntil = Date.now() + twelveHours;

            startDialogue("Bio-Bot", "TOO MANY ERRORS. SYSTEM LOCKOUT INITIATED. 12 HOUR COOLDOWN ACTIVE.", [
                { text: "Oh no...", action: () => {
                    startDialogue("Ratio", "Spectacular work, dunderhead! You've made the Bio-Bot cry AND triggered a lockout. Come back in 12 hours when you've had time to think about what you've done!", [
                        { text: "I'm sorry...", action: () => {
                            ecologyState.mistakes = 0;
                            ecologyState.selectedWords = { first: null, second: null };
                            ecologyState.currentSelection = 'first';
                            ecologyState.showPromptInterface = false;
                            gameState.gameMode = 'bioDomeMain';
                            gameState.player.x = 750;
                            gameState.player.y = 850;
                            saveEcologyGame();
                            closeDialogue();
                        }}
                    ]);
                }}
            ]);
        } else {
            startDialogue("Bio-Bot", "INCORRECT PROMPT. PLEASE BE CAREFUL. PLANTS ARE DELICATE.", [
                { text: "Try again", action: () => {
                    startDialogue("Ratio", "You're making the Bio-Bot sad. Think about what you learned in the Terra-Vault!", [
                        { text: "Go to Terra-Vault", action: () => {
                            ecologyState.selectedWords = { first: null, second: null };
                            ecologyState.currentSelection = 'first';
                            ecologyState.showPromptInterface = false;
                            gameState.gameMode = 'terraVault';
                            closeDialogue();
                        }},
                        { text: "Try again here", action: () => {
                            ecologyState.selectedWords = { first: null, second: null };
                            ecologyState.currentSelection = 'first';
                            closeDialogue();
                        }}
                    ]);
                }}
            ]);
        }
    }
}

const wordOptions = ['water', 'soil', 'light'];
let currentWordIndex = 0;

function cycleWordSelection(direction) {
    currentWordIndex = (currentWordIndex + direction + wordOptions.length) % wordOptions.length;
}

function selectCurrentWord() {
    const { ecologyState } = gameState;
    const selectedWord = wordOptions[currentWordIndex];

    if (ecologyState.currentSelection === 'first') {
        ecologyState.selectedWords.first = selectedWord;
        ecologyState.currentSelection = 'second';
    } else if (ecologyState.currentSelection === 'second') {
        ecologyState.selectedWords.second = selectedWord;
        ecologyState.currentSelection = 'submit';
    }
}

// Override handleKeyDown for ecology modes
const originalHandleKeyDown = handleKeyDown;
handleKeyDown = function(e) {
    const { gameMode, activeDialogue, ecologyState } = gameState;
    const key = e.key.toLowerCase();

    // Ecology-specific key handling
    if (gameMode === 'bioDomeMain' || gameMode === 'workbench' || gameMode === 'terraVault') {
        if (activeDialogue.isActive) {
            if (key === 'w' || key === 'arrowup') {
                activeDialogue.selectedOption = (activeDialogue.selectedOption - 1 + activeDialogue.options.length) % activeDialogue.options.length;
            } else if (key === 's' || key === 'arrowdown') {
                activeDialogue.selectedOption = (activeDialogue.selectedOption + 1) % activeDialogue.options.length;
            } else if (key === 'e' || key === 'enter') {
                if (activeDialogue.charIndex < activeDialogue.text.length) {
                    activeDialogue.charIndex = activeDialogue.text.length;
                } else if (activeDialogue.options.length > 0) {
                    activeDialogue.options[activeDialogue.selectedOption].action();
                } else {
                    closeDialogue();
                }
            }
            return;
        }

        if (ecologyState.showSpeciesSelection && gameMode === 'terraVault') {
            if (key === 'w' || key === 'arrowup') {
                ecologyState.speciesSelectionIndex = (ecologyState.speciesSelectionIndex - 1 + speciesDatabase.length) % speciesDatabase.length;
                return;
            } else if (key === 's' || key === 'arrowdown') {
                ecologyState.speciesSelectionIndex = (ecologyState.speciesSelectionIndex + 1) % speciesDatabase.length;
                return;
            } else if (key === 'e' || key === 'enter') {
                const selectedSpecies = speciesDatabase[ecologyState.speciesSelectionIndex];
                if (selectedSpecies.available) {
                    showHoloBloomInfo();
                }
                return;
            } else if (key === 'escape') {
                ecologyState.showSpeciesSelection = false;
                return;
            }
        }

        if (ecologyState.showPromptInterface && gameMode === 'workbench') {
            if (key === 'a' || key === 'arrowleft') {
                cycleWordSelection(-1);
                return;
            } else if (key === 'd' || key === 'arrowright') {
                cycleWordSelection(1);
                return;
            } else if (key === 'e' || key === 'enter') {
                if (ecologyState.currentSelection === 'submit') {
                    submitPrompt();
                } else {
                    selectCurrentWord();
                }
                return;
            } else if (key === 'w' || key === 'arrowup') {
                if (ecologyState.currentSelection === 'second') {
                    ecologyState.currentSelection = 'first';
                } else if (ecologyState.currentSelection === 'submit') {
                    ecologyState.currentSelection = 'second';
                } else {
                    ecologyState.currentSelection = 'submit';
                }
                return;
            } else if (key === 's' || key === 'arrowdown') {
                if (ecologyState.currentSelection === 'first') {
                    ecologyState.currentSelection = 'second';
                } else if (ecologyState.currentSelection === 'second') {
                    ecologyState.currentSelection = 'submit';
                } else {
                    ecologyState.currentSelection = 'first';
                }
                return;
            }
        }

        if (gameState.keys.hasOwnProperty(key)) {
            gameState.keys[key] = true;
            gameState.player.moving = true;
        }
        if (key === 'e') handleEcologyInteraction();
        return;
    }

    // Fall back to original handler for non-ecology modes
    originalHandleKeyDown(e);
};

// Update the main update function to handle ecology modes
const originalUpdate = update;
update = function(deltaTime) {
    const { gameMode, ecologyState } = gameState;

    if (gameMode === 'bioDomeMain' || gameMode === 'workbench' || gameMode === 'terraVault') {
        updateBioBotAnimation(deltaTime);
        handlePlayerAnimation(deltaTime);

        if (ecologyState.completeMessageTimer > 0) {
            ecologyState.completeMessageTimer -= deltaTime;
        }

        if (ecologyState.showPromptInterface) {
            if (ecologyState.promptInterfaceAlpha < 1) {
                ecologyState.promptInterfaceAlpha += 3 * deltaTime;
                if (ecologyState.promptInterfaceAlpha > 1) ecologyState.promptInterfaceAlpha = 1;
            }
        } else {
            ecologyState.promptInterfaceAlpha = 0;
        }

        if (gameState.activeDialogue.isActive || ecologyState.showSpeciesSelection) {
            if (gameState.activeDialogue.charIndex < gameState.activeDialogue.text.length) {
                gameState.activeDialogue.charIndex += 50 * deltaTime;
            }
            gameState.player.moving = false;
            return;
        }

        const { player, ratio, keys } = gameState;
        let newPlayerX = player.x;
        let newPlayerY = player.y;

        if (keys.w) { newPlayerY -= player.speed * deltaTime; player.frameY = 3; }
        if (keys.s) { newPlayerY += player.speed * deltaTime; player.frameY = 0; }
        if (keys.a) { newPlayerX -= player.speed * deltaTime; player.frameY = 2; ratio.direction = 'left'; }
        if (keys.d) { newPlayerX += player.speed * deltaTime; player.frameY = 1; ratio.direction = 'right'; }

        if (gameMode === 'terraVault') {
            if (newPlayerY < 640) {
                newPlayerY = 640;
            }
        }

        player.x = Math.max(0, Math.min(canvas.width - player.width, newPlayerX));
        player.y = Math.max(0, Math.min(canvas.height - player.height, newPlayerY));

        const dx = player.x - ratio.x;
        const dy = player.y - ratio.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > ratio.followDistance) {
            ratio.x += (dx / distance) * ratio.speed * deltaTime;
            ratio.y += (dy / distance) * ratio.speed * deltaTime;
        }

        gameState.nearbyObject = null;
        let currentInteractables = [];
        if (gameMode === 'bioDomeMain') currentInteractables = bioDomeInteractables;
        else if (gameMode === 'workbench') currentInteractables = workbenchInteractables;
        else if (gameMode === 'terraVault') currentInteractables = terraVaultInteractables;

        for (const obj of currentInteractables) {
            if (obj.id === 'ratio_ecology') {
                obj.x = ratio.x;
                obj.y = ratio.y;
            }
            if (checkCollision(player, obj)) {
                gameState.nearbyObject = obj;
                break;
            }
        }
        return;
    }

    originalUpdate(deltaTime);
};

function updateBioBotAnimation(deltaTime) {
    const { ecologyState } = gameState;
    ecologyState.bioBotBobOffset = Math.sin(Date.now() / 5000) * 1;
}

// Update the main draw function to handle ecology modes
const originalDraw = draw;
draw = function() {
    const { gameMode } = gameState;

    if (gameMode === 'bioDomeMain') {
        drawBioDomeMain();
        return;
    } else if (gameMode === 'workbench') {
        drawWorkbench();
        return;
    } else if (gameMode === 'terraVault') {
        drawTerraVault();
        return;
    }

    originalDraw();
};

function drawBioDomeMain() {
    if (bioDomeImage.complete) ctx.drawImage(bioDomeImage, 0, 0, canvas.width, canvas.height);

    const bioBotObj = bioDomeInteractables.find(obj => obj.id === 'biobot');
    const { ecologyState, player, ratio } = gameState;

    const bioBotWidth = 100;
    const bioBotHeight = 130;

    if (ecologyState.bioBotMood === 'sad') {
        if (bioBotSadImage.complete) {
            ctx.drawImage(bioBotSadImage, bioBotObj.x, bioBotObj.y + ecologyState.bioBotBobOffset, bioBotWidth, bioBotHeight);
        }
    } else {
        if (bioBotIdleStandingImage.complete) {
            ctx.drawImage(bioBotIdleStandingImage,
                bioBotObj.x, bioBotObj.y + ecologyState.bioBotBobOffset,
                bioBotWidth, bioBotHeight);
        }
    }

    drawPlayerAndRatioEcology();
    drawProgressionBar();
    drawEcologyHud();
    if (gameState.ecologyState.completeMessageTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 80, canvas.width, 60);
        ctx.font = '40px "Press Start 2P"';
        ctx.fillStyle = '#00FFFF';
        ctx.textAlign = 'center';
        ctx.fillText("Level 2 Completed!", canvas.width / 2, 125);
    }
    if (gameState.activeDialogue.isActive) drawDialogueBox();
}

function drawWorkbench() {
    if (workbenchImage.complete) ctx.drawImage(workbenchImage, 0, 0, canvas.width, canvas.height);

    const { ecologyState } = gameState;
    const bioBotWidth = 220;
    const bioBotHeight = 280;
    const bioBotX = 340;
    const bioBotY = 700;

    if (ecologyState.bioBotMood === 'sad') {
        ctx.shadowColor = '#FF6B6B';
        ctx.shadowBlur = 25;
    } else {
        ctx.shadowColor = '#4CAF50';
        ctx.shadowBlur = 20;
    }

    const finalY = bioBotY + ecologyState.bioBotBobOffset;

    if (ecologyState.bioBotMood === 'sad') {
        if (bioBotSadImage.complete) {
            ctx.drawImage(bioBotSadImage, bioBotX, finalY, bioBotWidth, bioBotHeight);
        }
    } else {
        if (bioBotIdleAnimationImage.complete) {
            const singleFrameWidth = 408;
            const singleFrameHeight = 612;
            const totalFrames = Math.floor(bioBotIdleAnimationImage.height / singleFrameHeight);
            const currentFrameIndex = Math.floor((Date.now() / 1500) % totalFrames);

            ctx.drawImage(bioBotIdleAnimationImage,
                0, currentFrameIndex * singleFrameHeight,
                singleFrameWidth, singleFrameHeight,
                bioBotX, finalY,
                bioBotWidth, bioBotHeight);
        }
    }
    ctx.shadowBlur = 0;

    if (gameState.ecologyState.mistakes > 0 && !gameState.ecologyState.levelComplete) {
        const mistakeBoxX = canvas.width - 270;
        const mistakeBoxY = 120;

        ctx.fillStyle = 'rgba(40, 20, 20, 0.9)';
        ctx.fillRect(mistakeBoxX, mistakeBoxY, 250, 70);
        ctx.strokeStyle = '#FF6B6B';
        ctx.lineWidth = 3;
        ctx.strokeRect(mistakeBoxX, mistakeBoxY, 250, 70);

        ctx.fillStyle = '#FF6B6B';
        ctx.font = 'bold 18px "Roboto Mono"';
        ctx.textAlign = 'left';
        ctx.fillText('⚠ MISTAKES', mistakeBoxX + 15, mistakeBoxY + 28);

        for (let i = 0; i < 2; i++) {
            ctx.fillStyle = i < gameState.ecologyState.mistakes ? '#FF4444' : '#444';
            ctx.beginPath();
            ctx.arc(mistakeBoxX + 50 + i * 60, mistakeBoxY + 50, 12, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.fillStyle = '#FFF';
        ctx.font = '14px "Roboto Mono"';
        ctx.fillText(`${gameState.ecologyState.mistakes}/2`, mistakeBoxX + 180, mistakeBoxY + 55);
    }

    if (gameState.ecologyState.showPromptInterface) {
        drawPromptInterface();
    }

    drawProgressionBar();
    drawEcologyHud();
    if (gameState.ecologyState.completeMessageTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 80, canvas.width, 60);
        ctx.font = '40px "Press Start 2P"';
        ctx.fillStyle = '#00FFFF';
        ctx.textAlign = 'center';
        ctx.fillText("Level 2 Completed!", canvas.width / 2, 125);
    }
    if (gameState.activeDialogue.isActive) drawDialogueBox();
}

function drawTerraVault() {
    if (terraVaultImage.complete) ctx.drawImage(terraVaultImage, 0, 0, canvas.width, canvas.height);

    if (gameState.ecologyState.visitedTerraVault && !gameState.ecologyState.holoBloomInfoRead && holoBloomInfoImage.complete && !gameState.ecologyState.showSpeciesSelection) {
        const time = Date.now() / 1000;
        const floatOffset = Math.sin(time * 2) * 5;
        const centerX = canvas.width / 2;
        const centerY = 550 + floatOffset;
        const imgWidth = 140;
        const imgHeight = 105;

        ctx.shadowColor = '#00FFFF';
        ctx.shadowBlur = 20;
        ctx.globalAlpha = 0.9;
        ctx.drawImage(holoBloomInfoImage, centerX - imgWidth / 2, centerY - imgHeight / 2, imgWidth, imgHeight);
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
    }

    drawPlayerAndRatioEcology();

    if (gameState.ecologyState.showSpeciesSelection) {
        drawSpeciesSelection();
    }

    drawProgressionBar();
    drawEcologyHud();
    if (gameState.ecologyState.completeMessageTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 80, canvas.width, 60);
        ctx.font = '40px "Press Start 2P"';
        ctx.fillStyle = '#00FFFF';
        ctx.textAlign = 'center';
        ctx.fillText("Level 2 Completed!", canvas.width / 2, 125);
    }
    if (gameState.activeDialogue.isActive) drawDialogueBox();
}

function drawPlayerAndRatioEcology() {
    const { player, ratio } = gameState;

    const ratioImg = ratio.direction === 'left' ? ratioImageL : ratioImageR;
    if (ratioImg.complete) ctx.drawImage(ratioImg, ratio.x, ratio.y, ratio.width, ratio.height);

    if (playerImage.complete) {
        ctx.drawImage(playerImage, player.frameX * player.spriteWidth, player.frameY * player.spriteHeight,
            player.spriteWidth, player.spriteHeight, player.x, player.y, player.width, player.height);
    }
}

function drawSpeciesSelection() {
    const { ecologyState } = gameState;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const panelX = 200;
    const panelY = 100;
    const panelWidth = 1100;
    const panelHeight = 700;

    const gradient = ctx.createLinearGradient(panelX, panelY, panelX, panelY + panelHeight);
    gradient.addColorStop(0, 'rgba(30, 50, 70, 0.95)');
    gradient.addColorStop(1, 'rgba(20, 30, 50, 0.95)');
    ctx.fillStyle = gradient;
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);

    ctx.strokeStyle = '#00FFFF';
    ctx.lineWidth = 4;
    ctx.shadowColor = '#00FFFF';
    ctx.shadowBlur = 15;
    ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
    ctx.shadowBlur = 0;

    ctx.fillStyle = '#00FFFF';
    ctx.font = 'bold 32px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.fillText('TERRA-VAULT SPECIES DATABASE', canvas.width / 2, panelY + 50);

    const itemsPerRow = 2;
    const itemWidth = 450;
    const itemHeight = 140;
    const itemSpacing = 50;
    const startX = panelX + 80;
    const startY = panelY + 120;

    speciesDatabase.forEach((species, index) => {
        const row = Math.floor(index / itemsPerRow);
        const col = index % itemsPerRow;
        const x = startX + col * (itemWidth + itemSpacing);
        const y = startY + row * (itemHeight + itemSpacing);

        const isSelected = index === ecologyState.speciesSelectionIndex;

        if (isSelected) {
            ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
            ctx.fillRect(x - 10, y - 10, itemWidth + 20, itemHeight + 20);
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 15;
            ctx.strokeRect(x - 10, y - 10, itemWidth + 20, itemHeight + 20);
            ctx.shadowBlur = 0;
        }

        if (species.available) {
            ctx.fillStyle = 'rgba(0, 150, 150, 0.3)';
        } else {
            ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
        }
        ctx.fillRect(x, y, itemWidth, itemHeight);
        ctx.strokeStyle = species.available ? '#00AAAA' : '#555';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, itemWidth, itemHeight);

        ctx.font = 'bold 24px "Roboto Mono"';
        ctx.textAlign = 'left';
        ctx.fillStyle = species.available ? '#00FFFF' : '#666';
        ctx.fillText(species.name, x + 20, y + 40);

        ctx.font = '18px "Roboto Mono"';
        ctx.fillStyle = species.available ? '#87CEEB' : '#555';
        ctx.fillText(`Class: ${species.class}`, x + 20, y + 75);

        if (!species.available) {
            ctx.font = 'bold 40px "Roboto Mono"';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';
            ctx.fillText('🔒', x + itemWidth - 50, y + 80);
        }

        ctx.font = '16px "Roboto Mono"';
        ctx.textAlign = 'left';
        if (species.available) {
            ctx.fillStyle = '#4CAF50';
            ctx.fillText('[ AVAILABLE ]', x + 20, y + 110);
        } else {
            ctx.fillStyle = '#FF6B6B';
            ctx.fillText('[ LOCKED ]', x + 20, y + 110);
        }
    });

    const instrY = panelY + panelHeight - 50;
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 20px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.fillText('Use W/S to navigate | Press E to select | ESC to close', canvas.width / 2, instrY);
}

function drawPromptInterface() {
    const { ecologyState } = gameState;
    const alpha = ecologyState.promptInterfaceAlpha;

    ctx.globalAlpha = alpha;

    const boxX = 795;
    const boxY = 200;
    const boxWidth = 560;
    const boxHeight = 350;

    const gradient = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxHeight);
    gradient.addColorStop(0, 'rgba(230, 240, 255, 0.98)');
    gradient.addColorStop(1, 'rgba(200, 220, 240, 0.98)');
    ctx.fillStyle = gradient;
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
    ctx.strokeStyle = '#2C5F8D';
    ctx.lineWidth = 4;
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

    ctx.fillStyle = '#2C5F8D';
    ctx.fillRect(boxX, boxY, boxWidth, 40);
    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 18px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.fillText('BIO-BOT INSTRUCTION PANEL', boxX + boxWidth / 2, boxY + 28);

    ctx.fillStyle = '#000';
    ctx.font = 'bold 21px "Roboto Mono"';
    ctx.textAlign = 'left';

    const promptY = boxY + 90;
    ctx.fillText(`Pour `, boxX + 40, promptY);

    const blank1X = boxX + 160;
    const blankWidth = 150;
    const blankHeight = 45;

    if (ecologyState.currentSelection === 'first') {
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        ctx.fillRect(blank1X - 10, promptY - 35, blankWidth + 20, blankHeight + 10);
    }

    ctx.fillStyle = '#FFF';
    ctx.fillRect(blank1X, promptY - 30, blankWidth, blankHeight);
    ctx.strokeStyle = '#2C5F8D';
    ctx.lineWidth = 3;
    ctx.strokeRect(blank1X, promptY - 30, blankWidth, blankHeight);

    ctx.fillStyle = '#000';
    ctx.font = 'bold 19px "Roboto Mono"';
    ctx.textAlign = 'center';
    if (ecologyState.selectedWords.first) {
        ctx.fillText(ecologyState.selectedWords.first.toUpperCase(), blank1X + blankWidth / 2, promptY);
    } else if (ecologyState.currentSelection === 'first') {
        ctx.fillStyle = '#666';
        const currentWord = wordOptions[currentWordIndex];
        ctx.fillText(currentWord.toUpperCase(), blank1X + blankWidth / 2, promptY);
    } else {
        ctx.fillStyle = '#BBB';
        ctx.fillText('_____', blank1X + blankWidth / 2, promptY);
    }

    ctx.fillStyle = '#000';
    ctx.font = 'bold 21px "Roboto Mono"';
    ctx.textAlign = 'left';
    ctx.fillText(` into the pot.`, blank1X + blankWidth + 15, promptY);

    const line2Y = promptY + 60;
    ctx.fillText(`Place the seed into the pot.`, boxX + 40, line2Y);

    const line3Y = line2Y + 60;
    ctx.fillText(`Do not pour `, boxX + 40, line3Y);

    const blank2X = boxX + 310;

    if (ecologyState.currentSelection === 'second') {
        ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
        ctx.fillRect(blank2X - 10, line3Y - 35, blankWidth + 20, blankHeight + 10);
    }

    ctx.fillStyle = '#FFF';
    ctx.fillRect(blank2X, line3Y - 30, blankWidth, blankHeight);
    ctx.strokeStyle = '#2C5F8D';
    ctx.lineWidth = 3;
    ctx.strokeRect(blank2X, line3Y - 30, blankWidth, blankHeight);

    ctx.fillStyle = '#000';
    ctx.font = 'bold 19px "Roboto Mono"';
    ctx.textAlign = 'center';
    if (ecologyState.selectedWords.second) {
        ctx.fillText(ecologyState.selectedWords.second.toUpperCase(), blank2X + blankWidth / 2, line3Y);
    } else if (ecologyState.currentSelection === 'second') {
        ctx.fillStyle = '#666';
        const currentWord = wordOptions[currentWordIndex];
        ctx.fillText(currentWord.toUpperCase(), blank2X + blankWidth / 2, line3Y);
    } else {
        ctx.fillStyle = '#BBB';
        ctx.fillText('_____', blank2X + blankWidth / 2, line3Y);
    }

    ctx.fillStyle = '#000';
    ctx.font = 'bold 21px "Roboto Mono"';
    ctx.textAlign = 'left';
    ctx.fillText(`.`, blank2X + blankWidth + 15, line3Y);

    const submitY = boxY + boxHeight - 70;
    const submitX = boxX + boxWidth / 2 - 100;
    const submitWidth = 200;
    const submitHeight = 50;

    if (ecologyState.currentSelection === 'submit') {
        ctx.fillStyle = '#00CC00';
        ctx.shadowColor = '#00FF00';
        ctx.shadowBlur = 20;
    } else {
        ctx.fillStyle = '#4CAF50';
    }
    ctx.fillRect(submitX, submitY, submitWidth, submitHeight);
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#2E7D32';
    ctx.lineWidth = 3;
    ctx.strokeRect(submitX, submitY, submitWidth, submitHeight);

    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 15px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.fillText('SUBMIT', submitX + submitWidth / 2, submitY + 32);

    const instrY = boxY + boxHeight + 20;
    const instrBoxWidth = 560;
    ctx.fillStyle = 'rgba(44, 95, 141, 0.95)';
    ctx.fillRect(boxX + boxWidth / 2 - instrBoxWidth / 2, instrY, instrBoxWidth, 45);
    ctx.strokeStyle = '#FFF';
    ctx.lineWidth = 2;
    ctx.strokeRect(boxX + boxWidth / 2 - instrBoxWidth / 2, instrY, instrBoxWidth, 45);

    ctx.fillStyle = '#FFF';
    ctx.font = 'bold 13px "Roboto Mono"';
    ctx.textAlign = 'center';
    ctx.fillText('Use A/D to cycle words | W/S to change field | E to select/submit', boxX + boxWidth / 2, instrY + 28);

    ctx.globalAlpha = 1.0;
}

function drawEcologyHud() {
    if (!gameState.activeDialogue.isActive) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
        ctx.textAlign = 'center';
        ctx.font = '22px "Roboto Mono"';
        ctx.fillStyle = '#FFFFFF';

        if (gameState.nearbyObject) {
            const textPart1 = "Press ";
            const textPart2 = "[E]";
            const textPart3 = ` to interact with ${gameState.nearbyObject.name}`;

            const originalTextAlign = ctx.textAlign;
            ctx.textAlign = 'left';

            const text1Width = ctx.measureText(textPart1).width;
            const text2Width = ctx.measureText(textPart2).width;
            const text3Width = ctx.measureText(textPart3).width;
            const totalWidth = text1Width + text2Width + text3Width;
            let currentX = (canvas.width / 2) - (totalWidth / 2);

            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(textPart1, currentX, canvas.height - 30);
            currentX += text1Width;

            ctx.fillStyle = '#FFFF00';
            ctx.fillText(textPart2, currentX, canvas.height - 30);
            currentX += text2Width;

            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(textPart3, currentX, canvas.height - 30);

            ctx.textAlign = originalTextAlign;
        } else if (gameState.gameMode === 'workbench' && !gameState.ecologyState.showPromptInterface) {
            ctx.fillText("Use WASD to move", canvas.width / 2, canvas.height - 30);
        }
    }

    const navWidth = 300;
    const navHeight = 160;
    const navX = canvas.width - navWidth - 20;
    const navY = 20;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(navX, navY, navWidth, navHeight);
    ctx.strokeStyle = '#00FFFF';
    ctx.lineWidth = 2;
    ctx.strokeRect(navX, navY, navWidth, navHeight);

    ctx.fillStyle = '#00FFFF';
    ctx.font = 'bold 18px "Roboto Mono"';
    ctx.textAlign = 'left';
    ctx.fillText("NAVIGATION", navX + 10, navY + 25);

    ctx.fillStyle = '#FFFFFF';
    ctx.font = '16px "Roboto Mono"';
    const navLineY = navY + 50;

    if (gameState.gameMode === 'bioDomeMain') {
        ctx.fillText("Current: Bio-Dome Main", navX + 10, navLineY);
        ctx.fillStyle = '#FFFF00';
        ctx.fillText("• Talk to Ratio for help", navX + 10, navLineY + 25);
        ctx.fillText("• Talk to Bio-Bot to start", navX + 10, navLineY + 50);
    } else if (gameState.gameMode === 'workbench') {
        ctx.fillText("Current: Workbench", navX + 10, navLineY);
        ctx.fillStyle = '#FFFF00';
        ctx.fillText("• Complete the challenge", navX + 10, navLineY + 25);
        ctx.fillText("• Visit Terra-Vault (left)", navX + 10, navLineY + 50);
    } else if (gameState.gameMode === 'terraVault') {
        ctx.fillText("Current: Terra-Vault", navX + 10, navLineY);
        ctx.fillStyle = '#FFFF00';
        ctx.fillText("• Read Holo-Bloom info", navX + 10, navLineY + 25);
        ctx.fillText("• Exit at bottom to return", navX + 10, navLineY + 50);
    }

    ctx.fillStyle = '#888';
    ctx.font = '14px "Roboto Mono"';
    ctx.fillText("Press E near Ratio to navigate", navX + 10, navY + navHeight - 10);
}

// INTEGRATION FUNCTIONS

function activateEcologyDoor() {
    const ecologyDoor = {
        id: 'ecology_door',
        name: 'Bio-Dome Entrance',
        x: 750,
        y: 350,
        width: 120,
        height: 200
    };
    level1Interactables.push(ecologyDoor);
}

function goToEcologyLevel() {
    gameState.gameMode = 'bioDomeMain';
    gameState.player.x = 750;
    gameState.player.y = 850;
    gameState.ratio.x = 700;
    gameState.ratio.y = 850;

    loadEcologyGame();

    if (!gameState.ecologyState.introDone) {
        setTimeout(() => {
            startDialogue("Ratio", "Welcome to the Bio-Dome, Cadet. This is where we study the ecology of modified plant species. Go talk to the Bio-Bot over there.", [
                { text: "Understood", action: closeDialogue }
            ]);
        }, 500);
    }
}

function goBackToLevel1() {
    gameState.gameMode = 'level1';
    gameState.player.x = 750;
    gameState.player.y = 500;
    gameState.ratio.x = 700;
    gameState.ratio.y = 500;
}

function passApiDataToEcology(data) {
    // Reserved for future use - could pass AI response data to ecology level
}

// Override the main-menu-button to handle ecology state
document.getElementById('main-menu-button').addEventListener('click', function() {
    if (gameState.gameMode === 'bioDomeMain' || gameState.gameMode === 'workbench' || gameState.gameMode === 'terraVault') {
        mainMenuEcology();
    }
});

// Override interaction handler for ecology modes
const originalHandleInteraction = handleInteraction;
handleInteraction = function() {
    const { gameMode } = gameState;

    if (gameMode === 'bioDomeMain' || gameMode === 'workbench' || gameMode === 'terraVault') {
        handleEcologyInteraction();
        return;
    }

    originalHandleInteraction();
};

// Load ecology assets
const ecologyAssetsToLoad = [
    bioDomeImage, workbenchImage, terraVaultImage,
    bioBotIdleStandingImage, bioBotIdleAnimationImage, bioBotHeadImage, bioBotSadImage,
    holoBloomInfoImage
];

ecologyAssetsToLoad.forEach(asset => {
    asset.onerror = () => {
        console.error(`Failed to load ecology image: ${asset.src}`);
    };
});

init();
    </script>
</body>
</html>
